# 思路
给一个二叉树，找到两个结点之间的路径之和的最大值，方法传入的参数就是根结点，看关键词： 路径和，思考之后根本没有思路，不知道如何切入

# 提示词
```txt
# 角色和目标

你好，请你扮演一位资深的Java开发工程师，同时也是一位擅长讲解算法的导师。

我的目标是彻底理解力扣124. 二叉树中的最大路径和，并学习解决这类问题的通用思路。请你以一个初级Java程序员能完全听懂的方式，为我提供详细的指导。

  

# 题目

124. 二叉树中的最大路径和， 理解题目含义，样例输入输出

# 我的思路

给一个二叉树，找到两个结点之间的路径之和的最大值，方法传入的参数就是根结点

# 我的困惑

思考之后根本没有思路，不知道如何切入，拿到这样一道题目，我如何进行思考？如何切入呢？

# 我希望的输出

请你根据以上信息，为我提供一份详细的题解，并满足以下要求：

1. 思路讲解：首先，请确认我的思路是否正确。然后，用通俗易懂的语言，分步骤详细讲解正确的解题思路，特别是针对我的困惑点进行解答。

2. 数据结构选择：选择合适的数据结构，并讲解为什么使用该数据结构

3. Java代码实现：提供一份完整、可运行的Java代码。 

4. 代码注释： 请在代码的关键部分加上详细的注释，解释这行代码（或代码块）的作用，让我能逐行理解。 

5. 复杂度分析： 在代码之后，请分析该算法的时间复杂度和空间复杂度。

```
# 题解
----
### 1. 思路讲解：如何从 0 到 1 思考这个问题

首先，你对题目的理解非常准确：**在给定的二叉树中，找到任意两个节点之间的一条路径，使得路径上所有节点值的总和最大。**

接下来，我们来解决你最大的困惑：“**如何切入？如何进行思考？**”

对于树形问题，一个极其重要的通用思考方法是 **“递归 (Recursion)”** 和 **“分解问题 (Divide and Conquer)”**。

为什么呢？因为树本身就是一个递归的结构：一棵大树由一个根节点和几棵小一点的子树构成，而每个子树本身又是一棵完整的树。所以，解决整棵树问题的方案，通常可以依赖于它子树的解决方案。

**让我们尝试把这个思想应用到本题中：**

**第一步：简化问题，聚焦于单个节点**

不要一开始就想整个树的路径，那太复杂了。我们把注意力集中在任意一个节点 `node` 上，思考：**对于这个节点 `node`，它能为“最大路径”贡献些什么？**

以 `node` 为“中心”的路径，有几种可能性？

1. 只有 `node` 自己。
    
2. 路径从 `node` 的左子树上来，经过 `node`，然后结束。
    
3. 路径从 `node` 的右子树上来，经过 `node`，然后结束。
    
4. **路径从 `node` 的左子树上来，穿过 `node`，再进入到 `node` 的右子树。**
    

这四种情况中，前三种路径都可以继续向上延伸，和 `node` 的父节点连接起来。但是，第四种情况形成了一个 “`V`” 字形（或倒 “`V`” 字形），它以 `node` 为转折点，**这条路径绝无可能再向上延伸去连接 `node` 的父节点了**，否则就会重复经过 `node`，不再是一条简单路径。

**第二步：定义递归函数的真正目的**

这就是本题最关键的思维转换点。我们发现，一个节点能做两件事：

1. **作为“贡献者”**：它可以为它的 **父节点** 提供一条向上的路径。这条路径只能是 `node.val` 加上其 **左、右子树中贡献较大的一条**。它不能同时要左右子树，否则就不能向上了。
    
2. **作为“转折点” (或叫“拱顶”)**：它可以将左、右子树的路径连接起来，形成一条完整的、不再延伸的路径 (`左子树贡献 + node.val + 右子树贡献`)。这条路径可以和我们全局的最终答案 `maxSum` 进行比较和更新。
    

这个发现告诉我们，一个简单的递归函数如果只返回一个值，是无法同时完成这两项使命的。

怎么办呢？

- **返回值**：我们就让递归函数返回它作为“贡献者”的值。我们把这个函数命名为 `maxGain(node)`，意为“节点 `node` 能提供的最大贡献值”。
    
- **副作用**：在计算这个贡献值的过程中，我们顺便计算出以 `node` 为“转折点”的路径和，用它来更新一个全局变量 `maxSum`。
    

**第三步：细化 `maxGain(node)` 函数的逻辑**

现在我们来定义 `maxGain(node)` 的具体行为：

1. **递归的终止条件（Base Case）**：如果 `node` 是 `null`，它对任何路径都没有贡献，直接返回 0。
    
2. **递归调用**：分别对左、右子节点调用 `maxGain`，得到它们能向上贡献的最大值。
    
    - `int leftGain = maxGain(node.left);`
        
    - `int rightGain = maxGain(node.right);`
        
3. **重要细节：处理负贡献**。如果一个子树的贡献值是负数，我们为什么要把它加到当前路径上呢？加上它只会让总和变小。所以，我们应该忽略所有贡献值为负的子树。我们可以通过 `Math.max(gain, 0)` 来实现这一点。
    
    - `int leftGain = Math.max(maxGain(node.left), 0);`
        
    - `int rightGain = Math.max(maxGain(node.right), 0);`
        
4. **更新全局最大路径和（作为“转折点”）**：现在我们有了处理过的左右子树贡献值。以当前 `node` 为转折点的路径和就是 `node.val + leftGain + rightGain`。我们用这个值来更新全局变量 `maxSum`。
    
    - `maxSum = Math.max(maxSum, node.val + leftGain + rightGain);`
        
5. **返回当前节点的贡献值（作为“贡献者”）**：当前节点 `node` 要想向上贡献，只能选择左、右路径中较大的一条，然后加上自己的值。
    
    - `return node.val + Math.max(leftGain, rightGain);`
        

通过这个递归函数，我们遍历树的每个节点。在每个节点，我们都完成了“更新全局答案”和“向父节点返回贡献”两个任务。当整个递归过程结束后，全局变量 `maxSum` 中存储的就是我们想要的最终答案。

### 2. 数据结构选择

- **`TreeNode`**：这是题目给定的数据结构，也是表示二叉树最自然、最标准的方式。它包含了节点值 `val` 和指向左右子节点的引用 `left` 和 `right`。我们自然地使用它来构建和遍历树。
    
- **一个实例变量 (Instance Variable)**：如上所述，我们需要一个在所有递归调用中都共享的变量来存储全局的最大路径和。在Java中，最方便的方法是在 `Solution` 类中定义一个实例变量，例如 `int maxSum`。这样，每次递归调用 `maxGain` 方法时，都可以访问和修改这个共享的 `maxSum`。
    

### 3. Java 代码实现

这是完整的、可以直接在力扣上运行的Java代码。

Java

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 * int val;
 * TreeNode left;
 * TreeNode right;
 * TreeNode() {}
 * TreeNode(int val) { this.val = val; }
 * TreeNode(int val, TreeNode left, TreeNode right) {
 * this.val = val;
 * this.left = left;
 * this.right = right;
 * }
 * }
 */
class Solution {
    // 定义一个实例变量来存储全局的最大路径和。
    // 初始化为整数的最小值，以确保任何有效的路径和都能比它大。
    private int maxSum = Integer.MIN_VALUE;

    /**
     * 这是主函数，用户将调用此方法。
     * @param root 二叉树的根节点
     * @return 树中的最大路径和
     */
    public int maxPathSum(TreeNode root) {
        // 调用递归辅助函数，从根节点开始计算。
        // maxGain函数的返回值我们在这里并不关心，因为它只是节点对父节点的“贡献”。
        // 我们真正的目标是在递归过程中更新 maxSum 变量。
        maxGain(root);
        
        // 当所有节点都遍历完毕后，maxSum 中存储的就是最终答案。
        return maxSum;
    }

    /**
     * 递归辅助函数，用于计算从任意节点出发向下的最大路径“贡献”。
     * 同时，它会利用子树的贡献值来更新全局的 maxSum。
     * @param node 当前节点
     * @return 从当前节点出发，向下延伸的单边路径的最大和（即对父节点的贡献）
     */
    private int maxGain(TreeNode node) {
        // 1. 递归的终止条件：如果节点为空，它的贡献为0。
        if (node == null) {
            return 0;
        }

        // 2. 递归计算左、右子树能提供的最大贡献值。
        // 如果子树的贡献值为负，我们就不选择它，而是认为它的贡献为0。
        // 这相当于剪除了负值路径。
        int leftGain = Math.max(maxGain(node.left), 0);
        int rightGain = Math.max(maxGain(node.right), 0);

        // 3. 更新全局最大路径和。
        // 在当前节点，它可以作为“转折点”，连接左、右子树，形成一条完整的路径。
        // 这条路径的和是 node.val + leftGain + rightGain。
        // 我们用这个值来尝试更新 maxSum。
        int priceNewPath = node.val + leftGain + rightGain;
        maxSum = Math.max(maxSum, priceNewPath);

        // 4. 返回当前节点作为“贡献者”能提供的最大值。
        // 这个值将用于其父节点的计算。
        // 路径只能选择左或右中的一条，不能两边都要，否则无法继续向上延伸。
        return node.val + Math.max(leftGain, rightGain);
    }
}
```

### 4. 复杂度分析

- **时间复杂度: O(N)**
    
    - 其中 N 是二叉树中节点的数量。
        
    - 我们的 `maxGain` 函数会对树中的每一个节点都访问且仅访问一次。因此，算法的运行时间与节点数量成正比。
        
- **空间复杂度: O(H)**
    
    - 其中 H 是二叉树的高度。
        
    - 这个空间开销主要来自于递归调用栈。在递归过程中，系统需要保存每一层调用的信息，直到递归返回。
        
    - 在最坏的情况下，如果二叉树退化成一条链表，树的高度 H 等于节点数 N，此时空间复杂度为 O(N)。
        
    - 在最好的情况下，如果二叉树是完全平衡的，树的高度 H 约等于 logN，此时空间复杂度为 O(logN)。
        

希望这份详尽的指南能帮助你彻底理解这道题。这种“递归函数返回A，但中途更新全局变量B”的模式在树和图的算法题中非常常见，掌握它会让你受益匪浅。如果你还有任何疑问，随时都可以提出来！


