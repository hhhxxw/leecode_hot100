

### 为什么不能直接用“先序遍历”来修改？

我们先看看如果严格按照“根 -> 左 -> 右”的顺序来修改会发生什么。

假设我们有这棵树：

```
      1
     / \
    2   5
```

1. **处理根节点 `1`**：根据先序遍历，`1` 的下一个节点是 `2`。我们想把 `1` 的右指针指向 `2`。
    
2. 执行 `root.right = root.left`。现在树变成了：
    
    ```
          1
         / \
        2   2  <-- 1的右指针指向了2
       / \
      ... ...
    ```
    
3. **灾难发生了！** 我们把 `root.right` 指向了左子树 `2`，但是原来指向右子树 `5` 的那条线索**永远地丢失了**。我们再也找不到节点 `5` 了。
    

这就是为什么我们不能在简单的先序遍历中直接修改指针。

### 为什么“右 -> 左 -> 根”的后序遍历是天才之举？

这个方法的精髓在于，**当我们准备处理一个节点 `root` 时，它的所有子孙节点都已经处理完毕，并且被完美地串成了一条链表**。

我们还是用一个具体的例子来走一遍，这会让你豁然开朗。

**初始树:**

```
      1
     / \
    2   5
   / \   \
  3   4   6
```

目标链表: 1 -> 2 -> 3 -> 4 -> 5 -> 6

pre 的初始值: null

#### 递归过程（可视化）

我们的调用顺序是 `flatten(1)` -> `flatten(5)` -> `flatten(6)`，一直走到最深、最右的节点。

**第1步：处理节点 `6`**

- `flatten(6)` 被调用。它的左右子树都是 `null`，递归到底。
    
- 开始处理节点 `6` 本身：
    
    - `root.right = pre;` (此时 `pre` 是 `null`) -> `6.right = null`
        
    - `root.left = null;` -> `6.left = null`
        
    - `pre = root;` -> `pre` 现在指向节点 `6`。
        
- **当前状态**：`pre` 指向 `[6]`。
    

**第2步：返回，处理节点 `5`**

- `flatten(6)` 结束，返回到 `flatten(5)`。
    
- `flatten(5)` 的右子树已经处理完。它的左子树是 `null`。
    
- 开始处理节点 `5` 本身：
    
    - `root.right = pre;` (此时 `pre` 是 `6`) -> `5.right = 6`
        
    - `root.left = null;` -> `5.left = null`
        
    - `pre = root;` -> `pre` 现在指向节点 `5`。
        
- **当前状态**：`pre` 指向 `[5 -> 6]` 这个链表。
    

**第3步：返回，处理节点 `4`**

- `flatten(5)` 结束，返回到 `flatten(1)`。现在 `flatten(1)` 开始调用 `flatten(2)`。
    
- `flatten(2)` 调用 `flatten(4)`。
    
- `flatten(4)` 的左右子树都是 `null`。
    
- 开始处理节点 `4` 本身：
    
    - `root.right = pre;` (此时 `pre` 是 `5`) -> `4.right = 5`
        
    - `root.left = null;` -> `4.left = null`
        
    - `pre = root;` -> `pre` 现在指向节点 `4`。
        
- **当前状态**：`pre` 指向 `[4 -> 5 -> 6]` 这个链表。
    

**第4步：返回，处理节点 `3`**

- `flatten(4)` 结束，返回到 `flatten(2)`。
    
- `flatten(2)` 调用 `flatten(3)`。
    
- `flatten(3)` 的左右子树都是 `null`。
    
- 开始处理节点 `3` 本身：
    
    - `root.right = pre;` (此时 `pre` 是 `4`) -> `3.right = 4`
        
    - `root.left = null;` -> `3.left = null`
        
    - `pre = root;` -> `pre` 现在指向节点 `3`。
        
- **当前状态**：`pre` 指向 `[3 -> 4 -> 5 -> 6]` 这个链表。
    

**第5步：返回，处理节点 `2`**

- `flatten(3)` 结束，返回到 `flatten(2)`。
    
- `flatten(2)` 的左右子树都已处理完。
    
- 开始处理节点 `2` 本身：
    
    - `root.right = pre;` (此时 `pre` 是 `3`) -> `2.right = 3`
        
    - `root.left = null;` -> `2.left = null`
        
    - `pre = root;` -> `pre` 现在指向节点 `2`。
        
- **当前状态**：`pre` 指向 `[2 -> 3 -> 4 -> 5 -> 6]` 这个链表。
    

**第6步：返回，处理根节点 `1`**

- `flatten(2)` 结束，返回到 `flatten(1)`。
    
- `flatten(1)` 的左右子树都已处理完。
    
- 开始处理节点 `1` 本身：
    
    - `root.right = pre;` (此时 `pre` 是 `2`) -> `1.right = 2`
        
    - `root.left = null;` -> `1.left = null`
        
    - `pre = root;` -> `pre` 现在指向节点 `1`。
        
- **当前状态**：`pre` 指向 `[1 -> 2 -> 3 -> 4 -> 5 -> 6]` 这个链表。
    

整个过程结束，原树的 `root` (节点1) 已经被完美地修改成了链表的头。

### 总结

这个算法就像是在**从后往前**构建链表。`pre` 始终扮演着“已构建好的链表的头节点”的角色。每处理一个新节点，就是把它变成新的头节点，然后把它的右指针指向旧的头节点，从而把链表接长。

所以，虽然我们的**目标**是得到一个**先序遍历**顺序的链表，但我们的**实现手段**却是一种**反向的先序遍历**（即 `右 -> 左 -> 根`），这样才能在不丢失指针的情况下，优雅地完成原地修改。
```java

/**

 * Definition for a binary tree node.

 * public class TreeNode {

 * int val;

 * TreeNode left;

 * TreeNode right;

 * TreeNode() {}

 * TreeNode(int val) { this.val = val; }

 * TreeNode(int val, TreeNode left, TreeNode right) {

 * this.val = val;

 * this.left = left;

 * this.right = right;

 * }

 * }

 */

class Solution {

    // 定义一个成员变量 pre，用于记录前一个被处理的节点。

    // 它可以看作是链表中，当前节点的前驱节点。

    private TreeNode pre = null;

  

    /**

     * 主函数，原地将二叉树展开为单链表。

     */

    public void flatten(TreeNode root) {

        // 递归的终止条件：如果节点为空，直接返回。

        if (root == null) {

            return;

        }

  

        // 1. 递归地拉平右子树

        // 按照 右 -> 左 -> 根 的顺序，我们先处理右子树

        flatten(root.right);

  

        // 2. 递归地拉平左子树

        flatten(root.left);

  

        // 3. 连接当前节点与已拉平的子树

        // 经过上面两步递归后，pre 变量现在指向的是 root 在先序遍历中的后继节点

        // （因为我们是反向处理的，所以 pre 是后继者）

        // 将当前节点的右指针指向 pre (即它的后继节点)

        root.right = pre;

        // 将当前节点的左指针设为 null

        root.left = null;

  

        // 4. 更新 pre 节点

        // 让当前节点成为下一个被处理节点的前驱

        pre = root;

    }

}
```