# 我的思路

我现在的思路是通过二叉树的遍历
- bfs
- dfs
使用一种方法，在遍历的同时维护一个变量sum，如果sum == target 就将结果+1，如果当前结点比目标结点还大直接跳过。


但是问题在于我如何在遍历的时候维护这个sum变量呢？请给我讲解解决二叉树问题的通法，并用java代码解决这道题目

# 提示词

```
# 角色和目标

你好，请你扮演一位资深的Java开发工程师，同时也是一位擅长讲解算法的导师。

我的目标是彻底理解力扣437. 路径总和 III，并学习解决这类问题的通用思路。请你以一个初级Java程序员能完全听懂的方式，为我提供详细的指导。

  

# 题目

437. 路径总和 III， 理解题目含义，样例输入输出

# 我的思路

我现在的思路是通过二叉树的遍历
- bfs
- dfs
使用一种方法，在遍历的同时维护一个变量sum，如果sum == target 就将结果+1，如果当前结点比目标结点还大直接跳过。

# 我的困惑

但是问题在于我如何在遍历的时候维护这个sum变量呢？请给我讲解解决二叉树问题的通法，并用java代码解决这道题目

# 我希望的输出

请你根据以上信息，为我提供一份详细的题解，并满足以下要求：

1. 思路讲解：首先，请确认我的思路是否正确。然后，用通俗易懂的语言，分步骤详细讲解正确的解题思路，特别是针对我的困惑点进行解答。

2. 数据结构选择：选择合适的数据结构，并讲解为什么使用该数据结构

3. Java代码实现：提供一份完整、可运行的Java代码。 

4. 代码注释： 请在代码的关键部分加上详细的注释，解释这行代码（或代码块）的作用，让我能逐行理解。 

5. 复杂度分析： 在代码之后，请分析该算法的时间复杂度和空间复杂度。
```

# 核心解法
> 将前缀和应用到树上

**前缀和 + 哈希表 (高效的通用解法)**

这是解决这类“路径和”问题的**通用大招**，也是面试官最希望看到的解法。

- **核心思想：** 想象一下在一维数组中，我们如何找“和为k的子数组”？我们会用一个“前缀和”的概念。如果从起点到位置 `j` 的和是 `sum_j`，从起点到位置 `i` 的和是 `sum_i`，那么从 `i+1` 到 `j` 的子数组和就是 `sum_j - sum_i`。我们想让这个和等于 `k`，即 `sum_j - sum_i = k`，变形一下就是 `sum_i = sum_j - k`。 所以，当我们遍历到 `j` 时，只需要回头看看，之前出现过多少个值为 `sum_j - k` 的前缀和 `sum_i`，就找到了多少个满足条件的子数组。
    
- **应用到树上：** 我们可以把这个思想应用到树的路径上。
    
    1. 我们从根节点开始进行一次DFS。在遍历过程中，我们记录一个 `currentSum`，表示从根节点到当前节点的路径总和。
        
    2. 当我们到达一个节点时，我们想知道，从它的某个祖先节点到它自己的这条路径，和是否为 `targetSum`。
        
    3. 这等价于：`currentSum - ancestorPathSum = targetSum`，变形后得到 `ancestorPathSum = currentSum - targetSum`。
        
    4. 所以，在当前节点，我们只需要问一个问题：“在从根到我父亲的这条路径上，出现过多少次值为 `currentSum - targetSum` 的前缀和？”
        
    5. 为了能快速回答这个问题，我们用一个**哈希表（HashMap）**来存储 `{前缀和: 出现次数}` 的映射。
        
- **关键细节：回溯** 当我们结束对一个节点的访问，准备返回到其父节点时，必须**撤销**当前节点对哈希表的影响。因为当前节点的前缀和只对它自己的子树有效，对它的兄弟节点是无效的。这个“撤销”操作，就是**回溯**。

# AC 代码
```java
import java.util.HashMap;

import java.util.Map;

  

/**

 * Definition for a binary tree node.

 * public class TreeNode {

 * int val;

 * TreeNode left;

 * TreeNode right;

 * TreeNode() {}

 * TreeNode(int val) { this.val = val; }

 * TreeNode(int val, TreeNode left, TreeNode right) {

 * this.val = val;

 * this.left = left;

 * this.right = right;

 * }

 * }

 */

class Solution {

    /**

     * 主函数，作为算法的入口

     */

    public int pathSum(TreeNode root, int targetSum) {

        // 创建一个HashMap来存储前缀和及其出现的次数

        // Key: 前缀和

        // Value: 该前缀和出现的次数

        Map<Long, Integer> prefixSumCount = new HashMap<>();

        // 初始化一个重要的基础情况：前缀和为0的路径出现了1次（即“空路径”）。

        // 这对于处理那些从根节点开始就满足条件的路径至关重要。

        // 例如，如果第一个节点的值就等于targetSum，那么 currentSum - targetSum = 0，

        // 我们需要能在map中找到这个0。

        prefixSumCount.put(0L, 1);

  

        // 调用递归辅助函数，开始深度优先搜索

        // 初始的前缀和是0

        return dfs(root, targetSum, prefixSumCount, 0L);

    }

  

    /**

     * 深度优先搜索的递归辅助函数

     * @param node           当前遍历到的节点

     * @param targetSum      目标和

     * @param prefixSumCount 存储前缀和的哈希表

     * @param currentSum     从根节点到当前节点的路径和（不含当前节点）

     * @return 以当前节点为根的子树中，和为targetSum的路径数量

     */

    private int dfs(TreeNode node, int targetSum, Map<Long, Integer> prefixSumCount, long currentSum) {

        // 递归终止条件：如果节点为空，说明这条路走到底了，没有路径，返回0

        if (node == null) {

            return 0;

        }

  

        // 1. 更新当前路径和

        currentSum += node.val;

  

        // 2. 查找并计算满足条件的路径数

        //    核心思想：currentSum - (currentSum - targetSum) = targetSum

        //    我们查找在到达当前节点之前，是否存在一个前缀和等于 (currentSum - targetSum)

        //    map.getOrDefault(key, 0) 表示如果找到了就返回对应的次数，找不到就返回0

        int count = prefixSumCount.getOrDefault(currentSum - targetSum, 0);

  

        // 3. 更新哈希表：将当前的前缀和加入哈希表，为子节点提供查询

        prefixSumCount.put(currentSum, prefixSumCount.getOrDefault(currentSum, 0) + 1);

  

        // 4. 递归进入左右子树

        //    将左右子树中找到的路径数，累加到当前count上

        count += dfs(node.left, targetSum, prefixSumCount, currentSum);

        count += dfs(node.right, targetSum, prefixSumCount, currentSum);

  

        // 5. 回溯！这是至关重要的一步！

        //    当结束对当前节点及其所有子节点的访问，准备返回到父节点时，

        //    必须将当前节点添加的前缀和记录从哈希表中“移除”，以免污染其他分支的计算。

        //    例如，当从左子树返回，准备进入右子树时，左子树的路径和不应该影响右子树。

        prefixSumCount.put(currentSum, prefixSumCount.get(currentSum) - 1);

        return count;

    }

}
```

# 理解回溯算法

### 核心比喻：探险家的足迹

想象一下，你是一个探险家，正在探索一个洞穴系统（我们的二叉树）。你有一个神奇的笔记本（`HashMap`），每走一步，你都会记下从洞口（根节点）到你当前位置的总距离（`currentSum`）。

- **“回溯”是什么？** 当你从一个岔路（比如左边的洞穴）探索到底，准备原路返回去探索右边的洞穴时，你必须**擦掉**刚才在左边洞穴里留下的所有距离记录。
    
- **为什么要擦掉？** 因为左边洞穴的距离记录，对于右边洞穴的探索是**无关的、错误的信息**。如果不擦掉，你的计算就会被这些“旧足迹”所干扰。
    

---

### 可视化示例

让我们用一个具体的例子来走一遍程序。

- **树**:
    
    ```
          10
         /  \
        5    -3
       / \    \
      3   2    11
     / \   \
    3  -2   1
    ```
    
- **targetSum**: `8`
    
- **`prefixSumCount` (笔记本) 初始状态**: `{ 0: 1 }` (这个0代表“还没出发时的状态”)
    

#### 旅程开始

**1. `dfs(node=10, currentSum=0)`**

- **下降**:
    
    - `currentSum` 更新为 `0 + 10 = 10`。
        
    - 查找 `map` 中是否有 `10 - 8 = 2` 的键？没有。`count = 0`。
        
    - 更新笔记本：`map.put(10, 1)`。**`map` 状态: `{ 0:1, 10:1 }`**
        
    - **向下走，去左边的洞穴 `5`**。
        

**2. `dfs(node=5, currentSum=10)`**

- **下降**:
    
    - `currentSum` 更新为 `10 + 5 = 15`。
        
    - 查找 `map` 中是否有 `15 - 8 = 7` 的键？没有。`count = 0`。
        
    - 更新笔记本：`map.put(15, 1)`。**`map` 状态: `{ 0:1, 10:1, 15:1 }`**
        
    - **向下走，去左边的洞穴 `3`**。
        

**3. `dfs(node=3, currentSum=15)`**

- **下降**:
    
    - `currentSum` 更新为 `15 + 3 = 18`。
        
    - 查找 `map` 中是否有 `18 - 8 = 10` 的键？**有！** 值为 `1`。这意味着从某个祖先到当前节点 `3` 的路径和为8。是哪条路径呢？就是从节点 `10` 之后开始的路径，即 `5 -> 3`。`count = 1`。
        
    - 更新笔记本：`map.put(18, 1)`。**`map` 状态: `{ 0:1, 10:1, 15:1, 18:1 }`**
        
    - **向下走，去左边的洞穴 `3` (叶子)**。
        

**4. `dfs(node=3(叶子), currentSum=18)`**

- ... 它的子节点都是 `null`，最终会从左右两边返回 `0`。
    
- **回溯 (Ascent)**: 从叶子节点 `3` 返回。
    
    - 执行 `prefixSumCount.put(21, prefixSumCount.get(21) - 1);`
        
    - **擦掉足迹！** 笔记本中关于 `currentSum=21` 的记录被减一。
        

**5. 返回到节点 `3` (父)**

- ... 探索它的右子树 `-2` ...
    
- **回溯 (Ascent)**: 从节点 `-2` 返回。
    
    - **擦掉足迹！** 笔记本中关于 `currentSum=16` 的记录被减一。
        
- **回溯 (Ascent)**: **现在，节点 `3` 的左右子树都探索完了，准备从节点 `3` 返回到它的父节点 `5`。**
    
    - 执行 `prefixSumCount.put(18, prefixSumCount.get(18) - 1);`
        
    - **擦掉足迹！** 笔记本中关于 `currentSum=18` 的记录被减一。
        

---

### **回溯的关键时刻**

**6. 返回到节点 `5`**

- 我们刚刚从它的左子树（以 `3` 为根）完全返回。
    
- **此时 `map` 的状态**：由于一路回溯，所有在 `5` 的左子树中产生的记录（如18, 21, 16等）都已经被清除了。`map` 又回到了我们刚要进入节点 `3` 探索之前的状态：**`{ 0:1, 10:1, 15:1 }`**。
    
- **现在，我们准备探索节点 `5` 的右子树，即 `dfs(node=2, ...)`**。
    

**这就是回溯的意义！** 如果我们不执行回溯，那么 `map` 里就会残留着 `{ 18:1, ... }` 这样的“脏数据”。当我们在右子树中计算时，可能会错误地使用这些来自左子树的“旧足迹”，导致计数错误。

**回溯保证了 `map` 里的所有前缀和，都严格属于从根节点到当前节点父节点的这一条路径上的记录，绝不会有来自“兄弟分支”的干扰。**

---

**7. `dfs(node=2, currentSum=15)`**

- **下降**:
    
    - `currentSum` 更新为 `15 + 2 = 17`。
        
    - 查找 `map` 中是否有 `17 - 8 = 9` 的键？没有。`count = 0`。
        
    - 更新笔记本：`map.put(17, 1)`。**`map` 状态: `{ 0:1, 10:1, 15:1, 17:1 }`**
        
    - ... 继续向下探索 ...
        

**8. 旅程结束**

- 当所有节点都经历过“下降”（更新map）和“回溯”（清理map）之后，整个递归结束，我们得到了最终的正确答案。
    

希望这个可视化的例子能让你彻底明白回溯的“擦掉足迹”的本质。它是在DFS中维护上下文纯净性的关键操作。
