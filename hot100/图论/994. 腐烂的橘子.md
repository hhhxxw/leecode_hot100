# 我的思路
先找到腐烂的橘子，然后从腐烂的橘子开始进行广度优先搜索，定义一个boolean数组，用来判断是否访问过
```java
class Solution {

    public int orangesRotting(int[][] grid) {

        // 行数

        int m = grid.length;

        int n = grid.length;

        int count = 0;

        boolean[][] flag = new boolean[m][n];

        for(int i = 0; i < m; i ++){

            for(int j = 0; j < n; j ++){

                if(grid[i][j] == 2){

                    bfs(i, j, flag, grid, count);

                }

            }

        }

  

    }

    public static void bfs(int i, int j, int[][]grid, boolean[][] flag, int count){

        // 使用队列

  

    }

}
```
目前代码只能写出这么多，主要不记得bfs怎么写了，也不知道如何嵌入这个思路中，用代码实现。

# 提示词
```
# 角色和目标

你好，请你扮演一位资深的Java开发工程师，同时也是一位擅长讲解算法的导师。

我的目标是彻底理解力扣994. 腐烂的橘子的这道题目，并学习解决这类问题的通用思路。请你以一个初级Java程序员能完全听懂的方式，为我提供详细的指导。

  

# 题目

994. 腐烂的橘子， 理解题目含义，样例输入输出

# 我的思路

先找到腐烂的橘子，然后从腐烂的橘子开始进行广度优先搜索，定义一个boolean数组，用来判断是否访问过
```java
class Solution {

    public int orangesRotting(int[][] grid) {

        // 行数

        int m = grid.length;

        int n = grid.length;

        int count = 0;

        boolean[][] flag = new boolean[m][n];

        for(int i = 0; i < m; i ++){

            for(int j = 0; j < n; j ++){

                if(grid[i][j] == 2){

                    bfs(i, j, flag, grid, count);

                }

            }

        }

  

    }

    public static void bfs(int i, int j, int[][]grid, boolean[][] flag, int count){

        // 使用队列

  

    }

}

# 我的困惑

不记得bfs怎么写了，也不知道如何根据思路用代码实现

# 我希望的输出

请你根据以上信息，为我提供一份详细的题解，并满足以下要求：

1. 思路讲解：首先，请确认我的思路是否正确。然后，用通俗易懂的语言，分步骤详细讲解正确的解题思路，特别是针对我的困惑点进行解答。

2. 数据结构选择：选择合适的数据结构，并讲解为什么使用该数据结构

3. Java代码实现：提供一份完整、可运行的Java代码。 

4. 代码注释： 请在代码的关键部分加上详细的注释，解释这行代码（或代码块）的作用，让我能逐行理解。 

5. 复杂度分析： 在代码之后，请分析该算法的时间复杂度和空间复杂度。
```

# 思路
你好！很高兴能以一位资深Java开发工程师和算法导师的身份，和你一起探讨这道经典的题目——“腐烂的橘子”。这道题是广度优先搜索（BFS）非常典型的应用场景，理解透彻后，对你解决类似“最短路径”、“最少步数”等问题会大有裨益。

别担心，BFS 的概念一旦理解，写起来其实是很有套路的。我们一步一步来拆解它。

---

### 1. 思路讲解

首先，我要肯定你的核心思路：**“先找到腐烂的橘子，然后从腐烂的橘子开始进行广度优先搜索”**。这完全正确！这正是解决这道题目的关键。

不过，你的初始代码中有几个小问题，这也是很多初学者容易遇到的困惑点，我们来详细梳理一下正确的、更完善的思路：

**这个过程就像现实中橘子腐烂一样：**

- **第0分钟**：有一些橘子已经是腐烂的。
    
- **第1分钟**：所有与第0分钟腐烂橘子相邻的新鲜橘子，会同时变腐烂。
    
- **第2分钟**：所有与第1分钟腐烂橘子相邻的新鲜橘子，也同时变腐烂。
    
- ...以此类推。
    

发现了吗？这种 **“一圈一圈”** 向外扩散的模式，正是**广度优先搜索（BFS）**最擅长解决的场景。BFS能够保证我们找到的是“最短时间”，因为它总是一层一层地处理，先处理完第1分钟能到达的所有节点，再处理第2分钟的，绝不会“跳级”。

针对你的困惑点：

你困惑的地方在于，如何用代码模拟这个“同时”腐烂以及“一分钟一分钟”推进的过程。你尝试在循环里对每个找到的腐烂橘子调用 bfs 方法，这会让每个腐烂橘子都独立开始一次完整的搜索，而无法模拟出它们协同、同时腐烂的效果。

**正确的解题步骤应该是这样的：**

1. **初始化 - 盘点家底**：
    
    - 创建一个**队列（Queue）**，这是实现BFS的核心数据结构。
        
    - 遍历整个 `grid` 网格，做两件事：
        
        - 把所有**初始腐烂橘子（值为2）** 的坐标 `(i, j)` 全部放入队列中。它们是我们BFS的“第一层”或“第0分钟”的起点。
            
        - 统计出所有**新鲜橘子（值为1）** 的总数 `freshCount`。这个计数器非常关键，它能帮助我们最后判断是否所有橘子都腐烂了。
            
2. **开始模拟 - BFS 循环**：
    
    - 启动一个 `while` 循环，条件是**队列不为空**。队列为空意味着腐烂过程已经无法再蔓延了。
        
    - 在 `while` 循环内部，我们需要一个机制来区分“分钟”，也就是**分层遍历**。这正是解决你困惑的核心技巧：
        
        - 在每一轮循环（代表新的一分钟开始）的开始，先记录下当前队列的大小 `size`。这个 `size` 代表了在上一分钟刚刚变腐烂、现在需要去感染邻居的橘子数量。
            
        - 然后，用一个 `for` 循环，不多不少，正好执行 `size` 次。每一次循环，我们从队列中取出一个腐烂橘子，并检查它的四个方向（上、下、左、右）的邻居。
            
        - 对于每一个邻居：
            
            - 检查坐标是否越界。
                
            - 检查这个位置是不是一个新鲜橘子 (`grid[i][j] == 1`)。
                
            - 如果满足条件，说明这个新鲜橘子被感染了。我们将其值变为 `2`，把它加入队列（为下一分钟做准备），并把 `freshCount` 减一。
                
    - 当处理完当前层的所有橘子（即 `for` 循环结束后），如果队列不为空（说明下一分钟还有橘子要腐烂），就将我们的**分钟计数器 `minutes` 加一**。
        
3. **最终判断 - 收尾工作**：
    
    - 当 `while` 循环结束后，检查 `freshCount`。
        
    - 如果 `freshCount == 0`，说明所有橘子都被成功腐烂了，返回 `minutes`。
        
    - 如果 `freshCount > 0`，说明有些新鲜橘子因为被空格子 `0` 隔开，永远无法被感染。根据题意，返回 `-1`。
        

**一个小优化**：我们不需要你代码中的 `boolean[][] flag` 访问数组。因为当一个新鲜橘子 `1` 变成腐烂橘子 `2` 后，它的值就不是 `1` 了，我们后续的判断 `grid[i][j] == 1` 自然就不会再次处理它，这起到了同样的效果，还节省了空间。

---

### 2. 数据结构选择

**队列（Queue）**

- **为什么用队列？** 队列的特性是“先进先出”（First-In, First-Out, FIFO）。
    
- **如何帮助我们？** 当我们把第0分钟的腐烂橘子全部放进队列后，我们先从队首取出橘子A，把它周围的新鲜橘子B和C放入队尾。然后取出下一个第0分钟的橘子D，把它周围的E放入队尾。这个过程保证了我们是按“层”或“分钟”来处理的。所有第0分钟的橘子处理完后，队列里剩下的就全都是第1分钟才变腐烂的橘子。这种特性完美契合了BFS逐层扩散的需求。
    
- 在Java中，我们通常使用 `java.util.Queue` 接口和它的实现类 `java.util.LinkedList` 来实现。
    

---

### 3. Java代码实现

```java
import java.util.LinkedList;
import java.util.Queue;

class Solution {
    public int orangesRotting(int[][] grid) {
        // 网格的行数和列数
        int rows = grid.length;
        int cols = grid[0].length;

        // 使用队列来实现BFS，队列中存储的是橘子的坐标，可以用一个长度为2的数组 [row, col] 表示
        Queue<int[]> queue = new LinkedList<>();
        // 统计新鲜橘子的数量
        int freshOranges = 0;

        // 步骤1: 遍历网格，找到所有初始的腐烂橘子和新鲜橘子的数量
        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < cols; j++) {
                if (grid[i][j] == 2) {
                    // 将腐烂的橘子加入队列，作为BFS的起始点
                    queue.offer(new int[]{i, j});
                } else if (grid[i][j] == 1) {
                    // 统计新鲜橘子的个数
                    freshOranges++;
                }
            }
        }

        // 如果一开始就没有新鲜橘子，直接返回0
        if (freshOranges == 0) {
            return 0;
        }

        // 分钟计数器
        int minutes = 0;
        // 定义四个方向的偏移量，方便地访问邻居
        int[][] directions = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}}; // 上, 下, 左, 右

        // 步骤2: 开始BFS，模拟腐烂过程
        while (!queue.isEmpty()) {
            // 获取当前这一分钟需要处理的腐烂橘子数量
            int levelSize = queue.size();
            boolean rottedInThisMinute = false;

            // 遍历当前层的所有腐烂橘子
            for (int i = 0; i < levelSize; i++) {
                int[] currentOrange = queue.poll();
                int r = currentOrange[0];
                int c = currentOrange[1];

                // 探索四个方向的邻居
                for (int[] dir : directions) {
                    int newRow = r + dir[0];
                    int newCol = c + dir[1];

                    // 检查邻居坐标是否有效，并且是否为新鲜橘子
                    if (newRow >= 0 && newRow < rows && newCol >= 0 && newCol < cols && grid[newRow][newCol] == 1) {
                        // 将新鲜橘子变为腐烂状态
                        grid[newRow][newCol] = 2;
                        // 将新腐烂的橘子加入队列，待下一分钟处理
                        queue.offer(new int[]{newRow, newCol});
                        // 新鲜橘子数量减一
                        freshOranges--;
                        // 标记这一分钟确实有橘子腐烂了
                        rottedInThisMinute = true;
                    }
                }
            }

            // 如果在这一分钟里有任何一个橘子腐烂了，时间才需要加一
            if (rottedInThisMinute) {
                minutes++;
            }
        }

        // 步骤3: 检查是否所有新鲜橘子都腐烂了
        // 如果循环结束后，freshOranges 仍大于0，说明有无法到达的橘子
        // 否则，返回总共花费的分钟数
        return freshOranges == 0 ? minutes : -1;
    }
}
```

---

### 4. 代码注释

上面的代码中已经包含了详细的注释，我再为你总结一下几个关键点：

- `Queue<int[]> queue = new LinkedList<>();`：创建队列，`int[]` 用来存储坐标 `[行, 列]`。
    
- `freshOranges` 计数器：这是解题的另一个核心，用于最后判断结果。
    
- 初始化的 `for` 循环：一次性遍历，把所有腐烂橘子（源头）入队，并统计好新鲜橘子总数。
    
- `while (!queue.isEmpty())`：BFS的主循环，只要还有能扩散的腐烂橘子，就继续。
    
- `int levelSize = queue.size();`：这是**分层遍历**的关键！它固定了当前“分钟”需要处理的橘子数，从而将不同时间腐烂的橘子在逻辑上分开。
    
- `for (int i = 0; i < levelSize; i++)`：处理当前分钟所有腐烂橘子的循环。
    
- `directions` 数组：一个优雅地处理四个方向邻居的小技巧，避免写四个重复的 `if` 语句块。
    
- `if (rottedInThisMinute)`: 这个判断确保了我们只在真正发生腐烂时才增加分钟数。考虑这种情况 `[[2, 1, 0], [1, 1, 0], [0, 1, 1]]`，最后一分钟腐烂完之后，队列里就空了，`while`循环结束，`minutes`就是正确的值。
    
- 最后的 `return freshOranges == 0 ? minutes : -1;`：根据 `freshOranges` 是否清零来返回最终结果。
    

---

### 5. 复杂度分析

- **时间复杂度: O(MtimesN)**
    
    - 其中 M 是网格的行数，N 是网格的列数。
        
    - **分析**：我们首先遍历一次网格来初始化队列和计数器，这花费 O(MtimesN) 的时间。之后，在BFS过程中，每个格子最多被访问一次（当它作为新鲜橘子被腐烂时入队，当它作为腐烂橘子去感染别人时出队）。因此，整个BFS过程也是 O(MtimesN)。总的时间复杂度就是 O(MtimesN)。
        
- **空间复杂度: O(MtimesN)**
    
    - **分析**：空间复杂度主要取决于队列 `queue` 的大小。在最坏的情况下，例如，如果整个网格几乎都是新鲜橘子，只有一个腐烂橘子在角落，那么队列在某一时刻可能会存储接近一半的橘子。在更极端的情况下，如果所有橘子都是新鲜的，只有一个腐烂橘子在中间，那么队列在某一时刻可能会存储所有与它相邻的橘子。在最坏的情况下，队列可能需要存储所有的橘子，所以空间复杂度为 O(MtimesN)。
        

希望这份详尽的题解能帮助你彻底攻克这道题，并对BFS建立起清晰的认识。如果还有任何疑问，随时都可以再问我！