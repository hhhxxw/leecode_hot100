# 思路
如何遍历map，我忘记了
```java
class Solution {

    public int[] topKFrequent(int[] nums, int k) {

        // 前面是元素，后面是出现次数

        HashMap<Integer, Integer> hashmap = new HashMap<>();

        for(int i = 0; i < nums.length; i ++){

            if(hashmap.containsKey(nums[i])){

                hashmap.set(containsKey, hashmap.get(containsKey) + 1);

            }else{

                hashmap.set(containsKey, 1);

            }

        }

        // 按照map的值进行排序, 选择第k个

    }

}
```
学会遍历之后优化的代码

```java
class Solution {

    public int[] topKFrequent(int[] nums, int k) {

        // 前面是元素，后面是出现次数

        HashMap<Integer, Integer> hashmap = new HashMap<>();

        for(int i = 0; i < nums.length; i ++){

            if(hashmap.containsKey(nums[i])){

                hashmap.put(containsKey, hashmap.get(containsKey) + 1);

            }else{

                hashmap.put(containsKey, 1);

            }

        }

        int[] arr = new int[hashmap.size()];

        int count = 0;

        // 按照map的值进行排序, 选择第k个

        for (Map.Entry<Integer, Integer> entry : hashmap.entrySet()) {

            int key = entry.getKey();  

            int value = entry.getValue();

            arr[count ++ ] = value;

        }

        Arrays.sort(arr);

        Array

    }

}
```

# 提示词
```
# 角色和目标

你好，请你扮演一位资深的Java开发工程师，同时也是一位擅长讲解算法的导师。

我的目标是彻底理解347. 前 K 个高频元素的这道题目，并学习解决这类问题的通用思路。请你以一个初级Java程序员能完全听懂的方式，为我提供详细的指导。

# 题目

347. 前 K 个高频元素， 理解题目含义，样例输入输出

# 我的思路
class Solution {

    public int[] topKFrequent(int[] nums, int k) {

        // 前面是元素，后面是出现次数

        HashMap<Integer, Integer> hashmap = new HashMap<>();

        for(int i = 0; i < nums.length; i ++){

            if(hashmap.containsKey(nums[i])){

                hashmap.set(containsKey, hashmap.get(containsKey) + 1);

            }else{

                hashmap.set(containsKey, 1);

            }

        }

        // 按照map的值进行排序, 选择第k个

    }

}


# 我的困惑
如何遍历map，我忘记了


# 我希望的输出

请你根据以上信息，为我提供一份详细的题解，并满足以下要求：

1. 思路讲解：首先，请确认我的思路是否正确。然后，用通俗易懂的语言，分步骤详细讲解正确的解题思路，特别是针对我的困惑点进行解答。

2. 数据结构选择：选择合适的数据结构，并讲解为什么使用该数据结构

3. Java代码实现：提供一份完整、可运行的Java代码。 

4. 代码注释： 请在代码的关键部分加上详细的注释，解释这行代码（或代码块）的作用，让我能逐行理解。 

5. 复杂度分析： 在代码之后，请分析该算法的时间复杂度和空间复杂度。

6. 给出leecode相同思路的题目

7. 给出的笔记符合obsidian格式，并美化格式
```

# 题解

### 核心思路

我的思路是：

1. 使用 `HashMap` 统计每个数字出现的频率。
    
2. 对 `HashMap` 的值（频率）进行排序，然后取出前 K 个元素。
    

这个方向是完全正确的！你遇到的困惑是“如何遍历和排序 `HashMap`”。这正是解决这道题目的关键所在。`HashMap` 本身是无序的，所以我们不能直接对它进行排序。我们需要借助其他数据结构来完成排序这个步骤。

这里，我将为你介绍一种最适合解决“前 K 个”这类问题的通用数据结构——**最小堆（Min-Heap）**，在 Java 中，我们通常使用 `PriorityQueue` 来实现它。

---

### # 1. 题目理解

**题目：** 347. 前 K 个高频元素

输入： 一个整数数组 nums 和一个整数 k。

输出： 一个包含 k 个频率最高的整数的数组。

**示例：**

- `nums = [1,1,1,2,2,3]`, `k = 2`
    
- `输出 = [1,2]` (或 `[2,1]`)。因为 `1` 出现了3次，`2` 出现了2次，`3` 出现了1次。频率最高的两个是 `1` 和 `2`。
    

---

### # 2. 你的思路分析与我的建议

#### 2.1 你的思路分析

你的第一步非常正确：

Java

```java
// 我的思路
class Solution {
    public int[] topKFrequent(int[] nums, int k) {
        // 前面是元素，后面是出现次数
        HashMap<Integer, Integer> hashmap = new HashMap<>();
        for(int i = 0; i < nums.length; i ++){
            // 你的代码存在一些语法错误，这里帮你修正一下
            if(hashmap.containsKey(nums[i])){
                hashmap.put(nums[i], hashmap.get(nums[i]) + 1);
            }else{
                hashmap.put(nums[i], 1);
            }
        }
        // ... 后续步骤
    }
}
```

**修正与优化建议：**

- `hashmap.set(containsKey, ...)` 语法是错误的，`HashMap` 的方法是 `put`。
    
- `containsKey` 是一个方法，不能直接作为变量使用。
    
- 其实，统计频率的代码有更简洁的写法，Java 8 提供了 `getOrDefault` 方法，可以简化 `if/else` 判断。
    

#### 2.2 如何遍历 Map？

你问到如何遍历 `Map`，这是一个非常基础且重要的问题。`Map` 有多种遍历方式，最常用且最推荐的是使用 `entrySet()` 方法，它可以返回一个包含所有键值对（`Map.Entry` 对象）的集合。

Java

```java
// 遍历 Map 的正确方式
for (Map.Entry<Integer, Integer> entry : hashmap.entrySet()) {
    int key = entry.getKey();   // 获取键 (这里的数字元素)
    int value = entry.getValue(); // 获取值 (这里的频率)
    System.out.println("元素：" + key + "，频率：" + value);
}
```

这正是我们接下来要用到它的地方。

#### 2.3 为什么选择最小堆？

你想到对 `Map` 的值进行排序，然后取前 K 个。如果我们将所有的键值对都转换成列表，然后进行完整排序，其时间复杂度为 `O(N log N)`，其中 N 是不重复元素的个数。

而使用**最小堆**，我们可以将时间复杂度优化到 `O(N log k)`。它的核心思想是：

- 我们维护一个大小为 `k` 的最小堆。
    
- 堆里存放的是频率最高的 `k` 个元素。
    
- 新加入的元素，如果其频率比堆顶元素（最小频率）高，就将堆顶元素移除，并加入新元素。
    
- 这样，堆中始终保持着我们所需要的 `k` 个最高频率的元素。
    

---

### # 3. 算法详解 (基于最小堆)

我们将解题过程分为三个清晰的步骤：

#### **步骤 1：统计频率**

- 使用 `HashMap<Integer, Integer>`，键为数组中的数字，值为该数字出现的频率。
    
- 遍历输入数组 `nums`，填充 `HashMap`。
    

#### **步骤 2：构建最小堆**

- 创建一个 `PriorityQueue`，也就是最小堆。
    
- 堆中存放的是 `Map.Entry<Integer, Integer>`，表示 `(数字, 频率)`。
    
- **关键点**：我们需要自定义堆的排序规则，让它按照**频率从小到大**排序，这样堆顶总是频率最小的那个元素。
    
- 遍历 `HashMap` 中的所有键值对。
    
- 对于每一个键值对，先将其加入最小堆。
    
- 如果堆的大小超过了 `k`，则将堆顶元素（频率最小的那个）移除 (`poll()` 操作)。
    

#### **步骤 3：提取结果**

- 当遍历完 `HashMap` 后，最小堆中剩下的 `k` 个元素就是频率最高的 `k` 个。
    
- 将堆中的所有元素依次取出，放入一个结果数组中。
    

---

### # 4. Java代码实现

Java

```java
import java.util.*;

class Solution {

    /**
     * 解决 347. 前 K 个高频元素
     * @param nums 输入数组
     * @param k 频率最高的 k 个元素
     * @return 包含 k 个高频元素的数组
     */
    public int[] topKFrequent(int[] nums, int k) {

        // 步骤 1: 统计每个元素的频率
        // 使用 HashMap 存储 <元素, 频率>
        Map<Integer, Integer> frequencyMap = new HashMap<>();
        for (int num : nums) {
            // 使用 getOrDefault 方法简化代码，如果 num 不存在，默认为0，然后+1
            frequencyMap.put(num, frequencyMap.getOrDefault(num, 0) + 1);
        }

        // 步骤 2: 使用优先队列（最小堆）来筛选前 k 个高频元素
        // 优先队列中存放的是 Map.Entry，即 (元素, 频率)
        // new PriorityQueue<>((a, b) -> a.getValue() - b.getValue())
        // 这行代码是关键！它定义了堆的排序规则：a.getValue() - b.getValue()
        // 结果为负数时，a 排在 b 前面，也就是频率小的在前。
        // 这就创建了一个最小堆，堆顶元素永远是频率最小的。
        PriorityQueue<Map.Entry<Integer, Integer>> minHeap = 
            new PriorityQueue<>((a, b) -> a.getValue() - b.getValue());

        // 遍历频率Map，将键值对放入最小堆
        for (Map.Entry<Integer, Integer> entry : frequencyMap.entrySet()) {
            // 总是先将当前元素入堆
            minHeap.offer(entry);
            // 如果堆的大小超过了 k
            if (minHeap.size() > k) {
                // 移除堆顶元素（频率最小的那个），确保堆中只保留 k 个元素
                minHeap.poll();
            }
        }

        // 步骤 3: 提取最小堆中的元素作为结果
        // 最终，最小堆中剩下的 k 个元素就是频率最高的 k 个
        int[] result = new int[k];
        for (int i = 0; i < k; i++) {
            // 从堆中取出元素，并将其键（数字）放入结果数组
            result[i] = minHeap.poll().getKey();
        }

        return result;
    }
}
```

---

### # 5. 复杂度分析

- **时间复杂度：**
    
    - **步骤 1 (统计频率):** 遍历 `nums` 数组，时间复杂度为 O(N)，其中 N 是 `nums` 数组的长度。
        
    - **步骤 2 (构建最小堆):** 遍历 `frequencyMap`。假设 `frequencyMap` 中有 U 个不重复的元素 (UleN)。对于每个元素，我们执行一次堆操作 (`offer` 或 `poll`)，堆的大小最大为 k。堆操作的时间复杂度是 O(logk)。因此，这一步的时间复杂度是 O(Ulogk)。
        
    - **步骤 3 (提取结果):** 从堆中取出 k 个元素，每次操作为 O(logk)，所以时间复杂度为 O(klogk)。
        
    - **总时间复杂度：** O(N+Ulogk+klogk)。由于 UleN，并且 kleU，所以可以简化为 O(Nlogk)。
        
- **空间复杂度：**
    
    - **`frequencyMap`:** 最坏情况下，所有元素都不重复，`Map` 的大小为 N，空间复杂度为 O(N)。
        
    - **`minHeap`:** 堆中最多只存储 k 个元素，空间复杂度为 O(k)。
        
    - **总空间复杂度：** O(N+k)。
        

---

### # 6. 拓展：类似题目

掌握了这种“哈希表 + 堆”的通用模式，你就能解决一大类相关的“Top K”问题。

1. **215. 数组中的第 K 个最大元素：** 这道题的解法与我们刚才的思路非常相似，只是不需要哈希表统计频率，直接在数组上使用最小堆即可。
    
2. **692. 前 K 个高频单词：** 和本题完全一样，只是把数字换成了字符串，需要处理频率相同时的字母顺序排序。
    
3. **973. 最接近原点的 K 个点：** 依然是“Top K”问题，只不过排序的依据变成了点到原点的距离。
    

希望这份详细的笔记能帮助你彻底理解这道题目，并掌握这种通用的解题模式。继续加油！