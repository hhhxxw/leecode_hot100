# 思路

这种设计题，我一直做不来，其实思路我可以理解，就是一个类，他有构造方法，有两个函数，一个是新增函数，就是往数组中添加一个新元素；一个是返回当前数组的中位数。

我想，他是不是想要我添加成员变量？我现在写的代码，输出没有结果，也就是我的添加操作没有成功

![](https://cdn.nlark.com/yuque/0/2025/png/40921502/1756453952469-af5c83af-ce01-4ce2-8ba7-65da18c01705.png)

```
class MedianFinder {
    public static int count;
    public static int[] nums = new int[100005];
    public MedianFinder() {
        int count = 0;
    }
    
    public void addNum(int num) {
        nums[count ++] = num;
    }
    
    public double findMedian() {
        if(nums.length % 2 == 0){
            return (nums[nums.length / 2 - 1] + nums[nums.length / 2])/ (1.0);
        }else{
            return nums[nums.length / 2];
        }
    }
}

/**
 * Your MedianFinder object will be instantiated and called as such:
 * MedianFinder obj = new MedianFinder();
 * obj.addNum(num);
 * double param_2 = obj.findMedian();
 */
```

看过题解之后的AC代码

```
class MedianFinder {
    // java 中一般使用优先队列来完成堆的创建
    private PriorityQueue<Integer> maxHeap;
    private PriorityQueue<Integer> minHeap;
    public MedianFinder() {
        // 初始化堆, 默认是小顶堆
        minHeap = new PriorityQueue<>();
        maxHeap = new PriorityQueue<>(Collections.reverseOrder());
    }

    public void addNum(int num) {
        maxHeap.offer(num);
        minHeap.offer(maxHeap.poll());
        if(minHeap.size() > maxHeap.size()){
            maxHeap.offer(minHeap.poll());
        }
    }

    public double findMedian() {
        if(maxHeap.size() > minHeap.size()){
            return maxHeap.peek();
        }else{
            return (maxHeap.peek() + minHeap.peek()) / 2.0;
        }
    }
}

/**
 * Your MedianFinder object will be instantiated and called as such:
 * MedianFinder obj = new MedianFinder();
 * obj.addNum(num);
 * double param_2 = obj.findMedian();
 */
```

# 提示词

```
# 角色和目标

你好，请你扮演一位资深的Java开发工程师，同时也是一位擅长讲解算法的导师。

我的目标是彻底理解力扣295. 数据流的中位数的这道题目，并学习解决这类问题的通用思路。请你以一个初级Java程序员能完全听懂的方式，为我提供详细的指导。

# 题目

295. 数据流的中位数， 理解题目含义，样例输入输出

# 我的思路
这种设计题，我一直不理解，其实思路我可以理解，就是一个类，他有构造方法，有两个函数，一个是新增函数，就是往数组中添加一个新元素；一个是返回当前数组的中位数。

# 我的困惑
我思考，题目是不是想要我添加成员变量？我增加了两个成员变量，但是我现在写的代码，输出没有结果，也就是我的添加操作没有成功

# 我希望的输出

请你根据以上信息，为我提供一份详细的题解，并满足以下要求：

1. 思路讲解：首先，请确认我的思路是否正确。然后，用通俗易懂的语言，分步骤详细讲解正确的解题思路，特别是针对我的困惑点进行解答。

2. 数据结构选择：选择合适的数据结构，并讲解为什么使用该数据结构

3. Java代码实现：提供一份完整、可运行的Java代码。 

4. 代码注释： 请在代码的关键部分加上详细的注释，解释这行代码（或代码块）的作用，让我能逐行理解。 

5. 复杂度分析： 在代码之后，请分析该算法的时间复杂度和空间复杂度。

6. 给出leecode相同思路的题目，给出hot100的所有设计题的链接，并给出解决设计题的思路
```

# 题解

---

### 1. 思路讲解：从我的困惑出发

首先，分析一下我的思路和困惑。

**的我思路**：“一个类，他有构造方法，有两个函数，一个是新增函数，就是往数组中添加一个新元素；一个是返回当前数组的中位数。”

这个思路在理解题目要求层面是完全正确的！你已经准确地抓住了这个类的核心功能：`addNum` 和 `findMedian`。

**你的困惑**：“我思考，题目是不是想要我添加成员变量？我增加了两个成员变量，但是我现在写的代码，输出没有结果，也就是我的添加操作没有成功”

你的直觉也是对的， 要添加成员变量来存储数据流中的数字。你很可能下意识地选择了一个 `List` 或 `ArrayList` 作为成员变量。

让我们沿着这个“直觉”的思路走下去，看看会发生什么。

#### 朴素解法（为什么它不够好？）

如果我们用一个 `ArrayList` 来存储所有数字：

1. `addNum(int num)` **方法**：直接调用 `list.add(num)`。这个操作的时间复杂度是 O(1)（暂不考虑扩容）。看起来很高效！
2. `findMedian()` **方法**：为了找中位数，我们必须先对列表进行排序，比如调用 `Collections.sort(list)`。排序的时间复杂度是 O(N log N)，其中 N 是当前列表中的元素数量。排序后，取出中间位置的数，时间复杂度是 O(1)。所以，`findMedian()` 的总复杂度是 O(N log N)。

**问题在哪里？**这道题描述的是“数据流”，意味着 `addNum` 和 `findMedian` 会被频繁交替调用。每次调用 `findMedian` 都要进行一次 O(N log N) 的排序，当数据量 N 变得很大时，这个开销是巨大的，会导致超时。

**核心矛盾**：我们需要一个数据结构，它既能**高效地添加元素**，又能**快速地找到中位数**。而简单的数组/列表无法同时满足这两个要求。

#### 正确的解题思路：分而治之

中位数是什么？它是一个分界点，把一组排好序的数分成**数量相等**（或几乎相等）的**较小的一半**和**较大的一半**。

- 如果总数是奇数，中位数就是较小一半中最大的那个数。
- 如果总数是偶数，中位数就是较小一半中最大的数 和 较大一半中最小的数 的平均值。

这个“分界”的思想就是解决问题的钥匙！

我们可以用两个“容器”来分别存放这两半数据：

1. 一个容器存放**较小的一半**数字。
2. 另一个容器存放**较大的一半**数字。

为了能快速拿到“较小一半的最大值”和“较大一半的最小值”，我们需要这两个容器有特殊的性质。这自然就引出了我们对数据结构的选择。

---

### 2. 数据结构选择：双堆（Dual Heaps）

什么样的“容器”能让我们快速拿到最大值或最小值呢？答案是 **堆（Heap）**。

- **大顶堆 (Max-Heap)**：堆顶永远是堆中最大的元素。非常适合用来存放“较小的一半”，因为我们随时需要拿到这一半中的最大值。
- **小顶堆 (Min-Heap)**：堆顶永远是堆中最小的元素。非常适合用来存放“较大的一半”，因为我们随时需要拿到这一半中的最小值。

在Java中，`PriorityQueue` 就是堆的实现。

- `new PriorityQueue<>()` 默认是一个小顶堆。
- `new PriorityQueue<>((a, b) -> b - a)` 或 `new PriorityQueue<>(Collections.reverseOrder())` 可以创建一个大顶堆。

#### 双堆协同工作的逻辑

我们创建两个成员变量：

- `maxHeap` (大顶堆): 存放数据流中较小的那一半数字。
- `minHeap` (小顶堆): 存放数据流中较大的那一半数字。

为了维持这种结构，我们必须遵守两个核心原则：

**原则一：平衡原则**两个堆的大小必须保持平衡。我们约定 `maxHeap` 的大小要么和 `minHeap` 相等，要么比 `minHeap` 多一个元素。

- 当总元素为偶数时，`maxHeap.size() == minHeap.size()`。
- 当总元素为奇数时，`maxHeap.size() == minHeap.size() + 1`。

**原则二：顺序原则**  
`maxHeap` (较小半部分) 中的所有元素都必须小于或等于 `minHeap` (较大半部分) 中的所有元素。

`addNum(int num)` **的实现流程：**

为了同时满足上述两个原则，我们可以设计一个巧妙的添加流程：

1. **先尝试加入** `maxHeap`：将新数字 `num` 加入 `maxHeap`。
2. **维护顺序原则**：`maxHeap` 中现在有了新元素，它不一定比 `minHeap` 的所有元素都小。为了维护顺序，我们从 `maxHeap` 中弹出堆顶（也就是当前较小部分的最大值），并将其加入 `minHeap`。
3. **维护平衡原则**：经过上一步，`minHeap` 的元素可能会过多。检查两个堆的大小，如果 `maxHeap` 的大小小于 `minHeap`，就从 `minHeap` 弹出堆顶（当前较大部分的最小值），并将其放回 `maxHeap`。

经过这三步，无论新加入的 `num` 是大是小，两个堆都能自动调整，并始终保持平衡和有序的状态。

`findMedian()` **的实现流程：**

因为我们始终维持着平衡，所以找中位数就变得非常简单了：

- 如果两个堆大小相等 (总数为偶数)，中位数就是 `(maxHeap.peek() + minHeap.peek()) / 2.0`。
- 如果 `maxHeap` 比 `minHeap` 大一 (总数为奇数)，中位数就是 `maxHeap.peek()`。

---

### 3. Java 代码实现

下面是完整的、带有详细注释的Java代码。

```
import java.util.PriorityQueue;
import java.util.Collections;

/**
 * LeetCode 295. 数据流的中位数
 *
 * 设计一个支持以下两种操作的数据结构：
 * void addNum(int num) - 从数据流中添加一个整数到数据结构中。
 * double findMedian() - 返回目前所有元素的中位数。
 */
class MedianFinder {

    // 成员变量：两个堆
    // maxHeap（大顶堆）用于存储数据流中较小的一半元素
    // 我们希望能够快速访问到较小一半元素中的最大值，所以使用大顶堆。
    private PriorityQueue<Integer> maxHeap;

    // minHeap（小顶堆）用于存储数据流中较大的一半元素
    // 我们希望能够快速访问到较大一半元素中的最小值，所以使用小顶堆。
    private PriorityQueue<Integer> minHeap;

    /**
     * 构造方法，初始化两个堆。
     */
    public MedianFinder() {
        // Java的PriorityQueue默认是小顶堆
        minHeap = new PriorityQueue<>();
        
        // 要创建大顶堆，需要提供一个自定义的比较器，实现降序排列
        maxHeap = new PriorityQueue<>(Collections.reverseOrder());
        // 或者使用Lambda表达式: new PriorityQueue<>((x, y) -> y - x);
    }
    
    /**
     * 从数据流中添加一个整数
     * @param num 新加入的数字
     */
    public void addNum(int num) {
        // 步骤1：先将新元素添加到大顶堆（maxHeap）
        // 这是一个临时的、为了方便平衡调整的步骤。
        maxHeap.offer(num);

        // 步骤2：将大顶堆的堆顶元素（当前较小部分的最大值）移动到小顶堆
        // 这一步是为了确保大顶堆里的所有元素都小于等于小顶堆里的元素。
        // 经过这一步，新元素 num 实际上被放到了它该去的位置（或者说，等价的效果）。
        minHeap.offer(maxHeap.poll());

        // 步骤3：检查并维持两个堆的平衡
        // 我们约定 maxHeap 的大小 >= minHeap 的大小。
        // 如果小顶堆的元素个数超过了大顶堆，说明失衡了。
        if (minHeap.size() > maxHeap.size()) {
            // 将小顶堆的堆顶元素（当前较大部分的最小值）移回大顶堆
            maxHeap.offer(minHeap.poll());
        }
    }
    
    /**
     * 返回目前所有元素的中位数
     * @return 中位数
     */
    public double findMedian() {
        // 根据两个堆的大小来判断总元素的奇偶性
        if (maxHeap.size() > minHeap.size()) {
            // 如果总元素个数是奇数，那么中位数就是大顶堆的堆顶元素。
            // 因为我们约定了大顶堆会多存一个元素。
            return maxHeap.peek();
        } else {
            // 如果总元素个数是偶数，中位数是两个堆顶元素的平均值。
            // 即较小一半的最大值和较大一半的最小值的平均值。
            // 注意要除以 2.0 来确保结果是浮点数。
            return (maxHeap.peek() + minHeap.peek()) / 2.0;
        }
    }
}

/**
 * Your MedianFinder object will be instantiated and called as such:
 * MedianFinder obj = new MedianFinder();
 * obj.addNum(num);
 * double param_2 = obj.findMedian();
 */
```

---

### 4. 复杂度分析

- **时间复杂度**：

- `addNum(int num)`: 每次添加涉及对两个堆的插入和删除操作。堆的插入（`offer`）和删除（`poll`）操作的时间复杂度都是 O(log N)，其中 N 是数据流中元素的总数。因为我们只执行常数次堆操作，所以 `addNum` 的总时间复杂度是 **O(log N)**。
- `findMedian()`: 这个操作只需要查看两个堆的堆顶元素（`peek`），这是一个 O(1) 的操作。所以 `findMedian` 的时间复杂度是 **O(1)**。

- **空间复杂度**：

- 我们需要将所有 N 个元素存储在两个堆中，所以空间复杂度是 **O(N)**。

这个解法完美地平衡了 `addNum` 和 `findMedian` 的效率，远优于朴素的排序解法。

---

### 5. 更多练习与思路延展

#### 相同思路的 LeetCode 题目

双堆结构是解决“动态中位数”或“第 K 大/小元素”问题的利器。

- [480. 滑动窗口中位数](https://leetcode.cn/problems/sliding-window-median/): 这是本题的加强版。窗口在滑动，意味着不仅有添加操作，还有删除操作。你需要对双堆进行修改以支持高效的删除。这道题是困难题，但核心思想一致。

#### LeetCode Hot 100 中的设计题

“设计题”考察的是你对数据结构的深刻理解和灵活运用能力。以下是 Hot 100 中一些经典的设计题，它们能极大地锻炼你的这种能力。

- [146. LRU 缓存](https://leetcode.cn/problems/lru-cache/): 经典中的经典。通常使用“哈希表 + 双向链表”的组合结构。
- [155. 最小栈](https://leetcode.cn/problems/min-stack/): 要求在 O(1) 时间内获取栈中最小元素。通常使用一个辅助栈来存储每个阶段的最小值。
- [208. 实现 Trie (前缀树)](https://leetcode.cn/problems/implement-trie-prefix-tree/): 设计一种专门用于字符串前缀搜索的数据结构。
- [232. 用栈实现队列](https://leetcode.cn/problems/implement-queue-using-stacks/): 使用两个栈来模拟队列的先进先出（FIFO）特性。
- [380. O(1) 时间插入、删除和获取随机元素](https://leetcode.cn/problems/insert-delete-getrandom-o1/): 需要结合使用哈希表和动态数组，巧妙处理删除操作。

#### 解决设计题的通用思路

1. **明确操作需求和性能要求**：首先分析题目要求实现哪些操作（如 `add`, `get`, `delete`, `findMin`），并特别注意题目对时间复杂度的要求，比如“请在 O(1) 时间内完成”。
2. **选择核心数据结构**：根据操作特性，选择最合适的基础数据结构。

- 需要快速查找？ -> **哈希表 (HashMap)**
- 需要有序？ -> **平衡二叉搜索树 (TreeMap/TreeSet)** 或 **跳表**
- 需要找最大/最小值？ -> **堆 (PriorityQueue)**
- 需要先进先出/后进先出？ -> **队列 (Queue)** / **栈 (Stack)**
- 需要高效插入删除，并维持顺序？ -> **双向链表 (LinkedList)**

3. **组合数据结构**：很多时候，单一数据结构无法满足所有要求。这时就要考虑将它们组合起来，发挥各自的优势。例如，LRU 缓存中的 `HashMap` 负责 O(1) 查找，`LinkedList` 负责维护访问顺序和 O(1) 删除。
4. **推演核心流程**：在纸上或脑中完整地模拟每个操作的流程。比如在“数据流的中位数”这题中，要推演一个新数字 `num` 是如何经过两个堆的“洗礼”最终让系统恢复平衡的。
5. **处理边界条件**：思考当数据结构为空、只有一个元素、或达到容量上限时，你的代码是否能正确处理。

希望这份详细的题解能帮你彻底搞懂这道题，并对如何解决设计题有一个清晰的认识。如果还有任何问题，随时可以继续提问！