# 思路
思路应该完全正确，但是又语法问题
```java
class Solution {
    public List<List<String>> groupAnagrams(String[] strs) {
        List<List<String>> res = new ArrayList<>();
        // 使用hashmap
        Map<String, List<String>> hashMap = new HashMap<>();
        for(String str : strs){
            String orderedString = (Arrays.sort(str.toCharArray())).toString();
            if(hashMap.containsKey(orderedString)){
                hashMap.get(orderedString).add(str);
            }else{
                hashMap.put(orderedString, new ArrayList<>().add(str));
            }
        }
        return list.add(hashMap.value());
    }
}
```

# 解决语法问题

1. **对 `void` 方法的结果调用 `.toString()`**
    
    - **问题代码**：
        
        Java
        
        ```
        String orderedString = (Arrays.sort(str.toCharArray())).toString();
        ```
        
    - **原因**：`Arrays.sort()` 方法是**原地排序**，它的返回类型是 `void`（即没有返回值）。你不能对一个 `void` 的结果调用任何方法，包括 `.toString()`。
        
    - **修正方案**：你需要先将字符串转为字符数组，然后对数组进行排序，最后再将排序后的字符数组转回字符串。
        
        Java
        
        ```
        char[] chars = str.toCharArray();
        Arrays.sort(chars);
        String orderedString = new String(chars);
        ```
        

---

2. **向 `Map` 中存入错误类型的值**
    
    - **问题代码**：
        
        Java
        
        ```
        hashMap.put(orderedString, new ArrayList<>().add(str));
        ```
        
    - **原因**：`ArrayList` 的 `.add()` 方法返回的是一个 `boolean` 值（表示添加是否成功），而不是 `ArrayList` 本身。你的 `Map` 定义的值类型是 `List<String>`，而你试图存入一个 `boolean`，这会导致类型不匹配的编译错误。
        
    - **修正方案**：你需要先创建一个新的列表，添加元素，然后再将这个列表存入 `Map`。
        
        Java
        
        ```
        List<String> newList = new ArrayList<>();
        newList.add(str);
        hashMap.put(orderedString, newList);
        ```
        

---

3. **返回语句的错误**
    
    - **问题代码**：
        
        Java
        
        ```
        return list.add(hashMap.value());
        ```
        
    - **原因**：
        
        - 变量 `list` 未定义。你可能想使用的是在方法开头定义的 `res`。
            
        - 获取 `Map` 的所有值应该使用 `.values()` 方法，而不是 `.value()`。
            
        - `.add()` 方法返回的是 `boolean`，而该方法的返回值类型要求是 `List<List<String>>`。
            
        - 你实际上是想返回 `Map` 中所有的值（也就是那些分组后的列表）。
            
    - **修正方案**：直接将 `Map` 的所有值集合转换成一个新的 `ArrayList` 并返回。
        
        Java
        
        ```
        return new ArrayList<>(hashMap.values());
        ```
        

---


下面是修正了所有问题后的完整代码。

Java

```java
import java.util.*;

class Solution {
    public List<List<String>> groupAnagrams(String[] strs) {
        // 如果输入为空或长度为0，直接返回空列表
        if (strs == null || strs.length == 0) {
            return new ArrayList<>();
        }
        
        Map<String, List<String>> hashMap = new HashMap<>();
        for (String str : strs) {
            // 修正问题1: 正确地对字符串进行排序
            char[] chars = str.toCharArray();
            Arrays.sort(chars);
            String orderedString = new String(chars);

            // 使用 computeIfAbsent 简化逻辑 (同时也修正了问题2)
            // 如果 key 不存在，则创建一个新的 ArrayList，然后执行 add 操作
            // 如果 key 已存在，则直接在现有的 List 上执行 add 操作
            hashMap.computeIfAbsent(orderedString, k -> new ArrayList<>()).add(str);
        }
        
        // 修正问题3: 正确地返回 Map 中所有的值
        return new ArrayList<>(hashMap.values());
    }
}
```

# 问题汇总
```
char[] tempArr = str.toCharArray();

            Arrays.sort(tempArr);

            // String orderedString = new String(tempArr);

            String orderedString = tempArr.toString();其中 // String orderedString = new String(tempArr);

            String orderedString = tempArr.toString();有什么区别，在大厂面试题中会涉及吗
```

在 Java 中，`new String(tempArr)` 和 `tempArr.toString()` 有着本质的区别，并且这个区别在技术面试（尤其是大厂面试）中是一个非常基础且重要的考察点。

下面详细解释两者的区别，以及为什么它在大厂面试中会涉及。

### 1. 核心区别

#### `new String(tempArr)`

- **作用：** 它是一个 `String` 类的构造方法。它的作用是**创建一个新的 `String` 对象**，这个新对象的内容完全由传入的字符数组 `tempArr` 中的字符构成。
    
- **返回值：** 返回的是一个可读的、包含所有字符的字符串，例如 `"abc"`, `"hello"`, `"123"` 等。
    
- **用途：** 这是将字符数组转换为字符串的**正确和常用**方式。
    

**示例：**

Java

```
char[] tempArr = {'c', 'b', 'a'};
Arrays.sort(tempArr); // 此时 tempArr 为 {'a', 'b', 'c'}
String orderedString = new String(tempArr);
System.out.println(orderedString); // 输出: "abc"
```

#### `tempArr.toString()`

- **作用：** `toString()` 是一个方法，它继承自 Java 的顶级父类 `java.lang.Object`。对于数组（如 `char[]`），`toString()` **没有被重写**。因此，它会调用 `Object` 类的默认实现。
    
- **返回值：** 默认的 `Object.toString()` 方法返回的是一个表示对象类型和其内存地址的字符串。格式通常是 `[类型名称@哈希码的十六进制]`。对于字符数组，类型名称是 `[C`（表示 `char` 数组）。
    
- **用途：** 它**不能**用来将数组的内容转换为字符串。它主要用于调试时查看数组对象在内存中的身份信息。
    

**示例：**

Java

```
char[] tempArr = {'c', 'b', 'a'};
Arrays.sort(tempArr); // 此时 tempArr 为 {'a', 'b', 'c'}
String orderedString = tempArr.toString();
System.out.println(orderedString); // 输出: "[C@5a1d743a" (具体哈希码会因运行而异)
```

### 2. 为什么在大厂面试中会涉及？

这个知识点之所以在大厂面试中非常重要，是因为它考察了候选人以下几个方面的**基础能力**：

1. **对 Java 基础类的理解（`String` vs `Object`）**：
    
    - 你是否清楚 `String` 类的特殊性以及它提供了哪些构造方法？
        
    - 你是否知道 `toString()` 方法的默认行为，以及它在哪些类中被重写（比如 `String`, `ArrayList` 等），在哪些类中没有被重写（比如数组）？
        
    - 这直接反映了你对 Java 核心 API 的熟悉程度。
        
2. **对数组和对象的基本认知**：
    
    - 数组在 Java 中也是一种对象，但它不是一个普通的对象，它的 `toString()` 方法没有被重写。
        
    - 区分数组对象本身和数组中的元素，是初学者常犯的错误。
        
3. **解决问题的严谨性**：
    
    - 面试官可能会通过类似的代码片段，看你是否能够立即发现并指出其中的**错误**。
        
    - 如果你能正确地指出 `tempArr.toString()` 无法得到想要的结果，并给出正确的解决方案 `new String(tempArr)`，说明你具备扎实的编程基础和严谨的思维。
        
4. **编码习惯和基础**：
    
    - 在大厂的面试中，面试官不仅关心你是否能解出算法题，更关心你编写代码时的基础是否牢固。
        
    - 这种对语言细节的掌握程度，是衡量一个程序员基础是否扎实的重要标准。
        

### 总结

- `new String(char[] c)`：用于将字符数组**内容**转换为字符串。
    
- `char[].toString()`：用于获取字符数组**对象**的内存地址信息，而不是其内容。
    

在面试中，如果你看到 `tempArr.toString()` 这样的代码用于将数组转换为字符串，你应该立即意识到这是**一个错误**，并能够清晰地解释原因。这种辨别能力是区分优秀和普通程序员的重要标志之一。

>为什么stringbuilder.toString 就是String呢

在 Java 中，`StringBuilder.toString()` 之所以会返回一个 `String` 对象，是因为 `StringBuilder` 类的设计目的和 `toString()` 方法在其内部的**特殊实现**。

这和我们之前讨论的数组 `char[].toString()` 是完全不同的情况。让我们来详细解析一下。

### 1. `StringBuilder` 和 `String` 的关系

- **`String`：** 是一个**不可变**的字符序列。一旦创建，它的内容就无法改变。
    
- **`StringBuilder`：** 是一个**可变**的字符序列。它内部维护一个可动态扩容的字符数组，可以高效地进行字符串的追加、插入、删除等操作。
    

`StringBuilder` 存在的意义就是为了在进行频繁的字符串修改操作时，避免因 `String` 的不可变性而产生大量临时对象，从而提高性能。

### 2. `toString()` 方法的“重写”

`StringBuilder` 类继承自 `Object` 类。在 Java 中，`Object` 类有一个默认的 `toString()` 方法，它返回的是对象的类型和内存地址。

但是，`StringBuilder` 的开发者（Sun/Oracle）**重写（Override）**了父类的 `toString()` 方法，使其具有了新的、更有意义的行为。

这个重写后的 `toString()` 方法的代码逻辑如下：

1. **创建一个新的 `String` 对象。**
    
2. **将 `StringBuilder` 内部维护的字符数组的内容，复制到这个新的 `String` 对象中。**
    
3. **返回这个新创建的 `String` 对象。**
    

这个过程就像是“拍照”一样：`StringBuilder` 是一个正在被修改的草稿，而 `toString()` 就像是把当前草稿的内容定稿，并保存为一个不可修改的副本（`String`）。

### 3. 为什么需要这样做？

`StringBuilder` 的核心用途就是作为构建字符串的工具。当所有操作完成后，我们通常需要一个最终、不可变的字符串结果来使用，例如作为方法的返回值、传递给其他需要 `String` 类型参数的API，或者用于打印输出。

因此，`StringBuilder.toString()` 方法的设计就是为了满足这个最终需求：将构建过程中的可变数据，转化为最终不可变的 `String` 结果。

### 总结

- **`char[].toString()`：** 没有被重写，调用的是 `Object` 默认的 `toString()`，所以返回内存地址。
    
- **`StringBuilder.toString()`：** 被**重写**了，它的实现逻辑就是创建一个新的 `String` 对象，并用 `StringBuilder` 的内容来初始化它。
    

这个区别再次体现了 Java 中面向对象编程的一个核心思想：**多态（Polymorphism）**。同一个方法名 `toString()`，在不同的类（数组 vs `StringBuilder`）中，可以表现出完全不同的行为，因为它们各自的 `toString()` 方法有着不同的实现。这正是为什么大厂面试非常看重对这些基础概念的理解。


# map中if-else 和 computeIfAbsent写法对比
好的，这两个代码片段的作用完全相同，都是为了实现一个常见的逻辑：**向一个 `Map<K, List<V>>` 中添加元素。如果 Map 中尚不存在对应的键（key），则创建一个新的 List，将元素加入，然后存入 Map；如果键已存在，则获取已有的 List，并将新元素加入其中。**

这通常用于按类别对数据进行分组，比如对字谜（anagrams）进行分组。

---

### 1. `if-else` 写法（传统/显式写法）

Java

```
if (hashMap.containsKey(orderedString)) {
    // 如果 key (orderedString) 已经存在
    // 1. 获取这个 key 对应的现有的 List
    List<String> list = hashMap.get(orderedString);
    // 2. 将当前的字符串 (str) 添加到这个 List 中
    list.add(str);
} else {
    // 如果 key (orderedString) 不存在
    // 1. 创建一个新的 ArrayList
    List<String> list = new ArrayList<>();
    // 2. 将当前的字符串 (str) 添加到这个新创建的 List 中
    list.add(str);
    // 3. 将这个新的 List 与 key (orderedString) 关联，并存入 hashMap
    hashMap.put(orderedString, list);
}
```

**解释:**

这段代码的逻辑非常直接，易于理解：

1. **检查存在性**：首先用 `containsKey()` 方法检查 `hashMap` 中是否已经有了 `orderedString` 这个键。
    
2. **存在的情况**：如果存在，就通过 `get()` 方法把与该键关联的 `List` 取出来，然后调用 `add()` 方法把新字符串 `str` 加进去。因为 Java 中对象是按引用传递的，所以我们修改了这个 `list` 对象，`hashMap` 中存储的那个 `List` 也相应地被修改了。
    
3. **不存在的情况**：如果不存在，就创建一个全新的 `ArrayList`，把 `str` 加到这个新列表里，最后通过 `put()` 方法，将这个新列表和 `orderedString` 这个键一起存入 `hashMap`。
    

**优点:**

- 逻辑清晰，对于 Java 初学者来说非常直观易懂。
    

**缺点:**

- 代码比较冗长，有较多的样板代码（boilerplate code）。
    

---

### 2. `computeIfAbsent` 写法（现代/函数式写法）

Java

```
// hashMap.computeIfAbsent(orderedString, k -> new ArrayList<>()).add(str);
```

**解释:**

这是自 Java 8 引入的 `Map` 接口的一个默认方法，它能极大地简化上面的 `if-else` 逻辑。

我们可以把它分解来看：

1. **`hashMap.computeIfAbsent(orderedString, k -> new ArrayList<>())`**
    
    - 这个方法会先去 `hashMap` 中查找键 `orderedString`。
        
    - **如果键存在**：它会直接返回该键对应的**值**（也就是那个已经存在的 `List`）。此时，第二个参数 `k -> new ArrayList<>()` 这个 Lambda 表达式**完全不会被执行**。
        
    - **如果键不存在**：它会自动执行第二个参数，也就是那个 Lambda 表达式 `k -> new ArrayList<>()`。这个表达式会创建一个 `new ArrayList<>()`，然后 `computeIfAbsent` 方法会把这个新创建的 `ArrayList` 存入 `hashMap`（与 `orderedString` 关联），并**返回这个新创建的 `ArrayList`**。
        
2. **`.add(str)`**
    
    - 无论上面的 `computeIfAbsent` 是返回了旧的 `List` 还是新创建的 `List`，这个方法调用的结果都是一个 `List` 对象。
        
    - 因此，我们可以直接在这个返回的 `List` 对象上链式调用 `add(str)` 方法，将新字符串添加进去。
        

**一句话总结 `computeIfAbsent` 的作用**：**“给我一个键，如果它对应的值不存在，你就用这个函数帮我创建一个新值存进去，最后把这个键对应的值（不管是旧的还是新的）返回给我。”**

**优点:**

- **代码极其简洁**：将 `if-else` 的 5-6 行代码缩减为 1 行。
    
- **表达力更强**：代码的意图非常明确，就是“计算/创建并获取值”。
    
- **线程安全**：在 `ConcurrentHashMap` 中，`computeIfAbsent` 是原子操作，能避免多线程环境下的竞态条件问题，而 `if-else` 写法在并发环境下需要手动加锁。
    

**缺点:**

- 对于不熟悉 Java 8 Lambda 表达式和 `Map` 新方法的开发者来说，可能需要一点时间来理解。
    

### 总结对比

|特性|`if-else` 写法|`computeIfAbsent` 写法|
|---|---|---|
|**可读性**|对初学者友好，非常直观|对熟悉 Java 8+ 的开发者更清晰|
|**简洁性**|冗长，样板代码多|非常简洁，一行代码搞定|
|**功能性**|基本功能|功能更强，返回计算后的值，支持链式调用|
|**线程安全**|在 `HashMap` 中非线程安全|在 `ConcurrentHashMap` 中是原子操作|

在现代的 Java 开发中，对于这种“检查-创建-放入”的场景，**强烈推荐使用 `computeIfAbsent`**，因为它更简洁、更具表现力，也是更地道的写法。

> 然后我发现我lambda又不记得了hh，木得办法，再通过这个代码学习一下

好的，我们通过 `hashMap.computeIfAbsent(orderedString, k -> new ArrayList<>())` 这个绝佳的例子，来详细介绍一下 Lambda 表达式。

### 什么是 Lambda 表达式？

从本质上讲，Lambda 表达式是一个**可以传递的匿名函数**。

让我们拆解这个定义：

- **函数（Function）**：它是一段代码块，有参数、有函数体、可能有返回值。就像一个普通的方法一样。
    
- **匿名（Anonymous）**：它没有方法名。
    
- **可以传递（Passable）**：你可以像传递一个变量（如整数、字符串）一样，将这段代码块作为方法的参数进行传递，或者让方法返回这段代码块。
    

在 Java 8 之前，如果你想传递一段代码逻辑，通常需要使用**匿名内部类**，代码非常笨重。Lambda 表达式的出现就是为了用一种更简洁、更清晰的方式来实现这一点，它也是 Java 引入函数式编程思想的核心。

---

### Lambda 表达式的语法

Lambda 表达式的语法非常简单，由三部分组成：

1. **参数列表**：位于 `->` 符号的左侧。
    
2. **箭头符号**：`->`
    
3. **函数体**：位于 `->` 符号的右侧。
    

Java

```
(parameter1, parameter2, ...) -> { code block }
```

**语法演进（从复杂到简洁）：**

1. **标准形式**：包含参数类型和花括号的代码块，需要 `return` 语句。
    
    Java
    
    ```
    (String s) -> {
        System.out.println(s);
        return s.length();
    }
    ```
    
2. **省略参数类型**：在大多数情况下，Java 编译器可以根据上下文推断出参数类型。
    
    Java
    
    ```
    (s) -> {
        System.out.println(s);
        return s.length();
    }
    ```
    
3. **单个参数时省略括号**：如果只有一个参数，可以省略参数列表的括号。
    
    Java
    
    ```
    s -> {
        System.out.println(s);
        return s.length();
    }
    ```
    
4. **单行函数体时省略花括号和 `return`**：如果函数体只有一行代码，可以省略花括号 `{}`。如果这一行是返回语句，那么 `return` 关键字也必须一同省略。
    
    Java
    
    ```
    s -> s.length() // 这一行代码的结果就是返回值
    ```
    
5. **无参数时使用空括号**：
    
    Java
    
    ```
    () -> System.out.println("Hello, World!")
    ```
    

---

### Lambda 表达式的基石：函数式接口 (Functional Interface)

Lambda 表达式虽然看起来像是独立的代码片段，但它**不能**凭空存在。**任何一个 Lambda 表达式都必须对应一个“函数式接口”类型**。

什么是函数式接口？

一个只包含一个抽象方法的接口，就被称为函数式接口。

为了标识一个接口是函数式接口，Java 提供了 `@FunctionalInterface` 注解。这不是必需的，但它是一个很好的实践，因为如果接口不满足条件（比如有多个抽象方法），编译器会报错。

**常见的函数式接口示例：**

|接口名|抽象方法|作用|
|---|---|---|
|`Runnable`|`void run()`|执行一个无参数无返回值的动作。|
|`Predicate<T>`|`boolean test(T t)`|接收一个参数，返回一个布尔值（用于判断）。|
|`Consumer<T>`|`void accept(T t)`|接收一个参数，进行消费，无返回值。|
|`Supplier<T>`|`T get()`|不接收参数，返回一个结果（用于提供数据）。|
|`Function<T, R>`|`R apply(T t)`|**接收一个参数 T，返回一个结果 R（用于转换）。**|

Lambda 表达式的参数列表和返回值类型，必须与它所实现的函数式接口的抽象方法相匹配。

---

### 回到我们的例子：`k -> new ArrayList<>()`

现在，我们用学到的知识来分析 `hashMap.computeIfAbsent(orderedString, k -> new ArrayList<>())` 中的 Lambda 表达式。

1. computeIfAbsent 方法签名
    
    这个方法的第二个参数要求传入一个 Function 类型的对象。Function 是一个函数式接口，它的抽象方法是：R apply(T t)。
    
    - `T` 是输入参数类型。
        
    - R 是返回值类型。
        
        在这个场景下，T 是 Map 的键（Key）类型，R 是 Map 的值（Value）类型。
        
2. **分析 Lambda 表达式 `k -> new ArrayList<>()`**
    
    - `k`：这是参数列表。它对应 `Function` 接口中 `apply` 方法的参数 `t`。在这里，`k` 就代表 Map 的键（`orderedString`）。
        
    - `->`：箭头符号。
        
    - `new ArrayList<>()`：这是函数体。它创建并隐式地返回了一个新的 `ArrayList` 对象。这个返回值的类型对应 `apply` 方法的返回值 `R`，也就是 Map 的值。
        
3. 组合起来理解
    
    我们传递的 k -> new ArrayList<>() 这个 Lambda 表达式，实际上是 Function 接口的一个简洁实现。它的含义是：“这是一个函数，它接收一个参数 k（虽然函数体里没用上它），然后返回一个全新的 ArrayList 实例”。
    
    当 `computeIfAbsent` 方法发现 `orderedString` 这个键不存在时，它就需要创建一个新的值。如何创建呢？它就会执行我们传给它的这个 Lambda 表达式，调用这个“函数”，拿到返回值（一个空的 `ArrayList`），然后把它和 `orderedString` 关联起来存入 Map 中。
    

### 总结：为什么 Lambda 如此强大？

通过这个例子，我们可以看到 Lambda 表达式的核心优势：

- **极致简洁**：对比需要写一个完整匿名内部类的旧方法，Lambda 表达式极大地减少了样板代码。
    
- **关注点分离**：`computeIfAbsent` 方法的开发者不关心“如何”创建一个新列表，他只关心在“需要时”有一个能创建列表的“功能”。Lambda 表达式让方法的调用者可以轻松地将这个“功能”注入进去。
    
- **行为参数化**：你可以将“行为”（一段代码逻辑）像数据一样传递给方法，这使得代码更加灵活和可复用，是函数式编程的核心思想。