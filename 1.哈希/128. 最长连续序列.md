# 思路
超时

```java
class Solution {

    public int longestConsecutive(int[] nums) {

        if(nums == null || nums.length == 0){

            return 0;

        }

        Map<Integer, Integer> hashmap = new HashMap<>();

        int count = 0;

        for(int i = 0; i < nums.length; i++){

            hashmap.put(nums[i], i);

        }

        for(int i = 0; i < nums.length; i++){

            int currentCount  = 1;

            int currentnum = nums[i];

            // 得到最开始的数字

            while(hashmap.containsKey(currentnum - 1)){

                currentnum --;

            }

            while(hashmap.containsKey(currentnum + 1)){

                currentCount ++;

                currentnum ++;

            }

            if(currentCount > count){

                count = currentCount;

            }

        }

        return count;

    }

}
```

# 提示词
分析一下leeode这道题目

128. 最长连续序列，分析我提供的代码思路，指出其问题所在，给出修改意见

# 题解
您好！您提供的代码思路非常清晰，逻辑上完全正确。对于这道经典的哈希表题目，您的代码已经实现了大部分核心思想。

我们来分步分析您的代码思路，并指出其可以优化的地方。

### 1. 代码思路分析

您的代码主要分为三个步骤：

1. **预处理：**
    
    - `Map<Integer, Integer> hashmap = new HashMap<>();`
        
    - `for(int i = 0; i < nums.length; i++){ hashmap.put(nums[i], i); }`
        
    - 这个步骤的目的是将数组中的所有数字都存入一个哈希表中。哈希表提供 O(1) 的平均时间复杂度来检查一个数字是否存在。这是解决此问题的关键。
        
2. **寻找序列的起点并计算长度：**
    
    - `for(int i = 0; i < nums.length; i++){ ... }`
        
    - 这个外层循环遍历了数组中的每一个数字 `nums[i]`。
        
    - `while(hashmap.containsKey(currentnum - 1)){ currentnum --; }`
        
    - 这个内层 `while` 循环非常巧妙。它的目的是**回溯**，从当前数字 `nums[i]` 开始，不断地向前寻找，直到找到这个连续序列的**最小数字（起点）**。例如，如果 `nums[i]` 是 `5`，这个循环会找到 `4`，然后 `3`，最终停在 `1`（假设 `1, 2, 3, 4, 5` 是连续的）。
        
    - `while(hashmap.containsKey(currentnum + 1)){ ... }`
        
    - 在找到起点后，这个 `while` 循环再从这个起点开始，不断地向后查找，计算连续序列的长度。
        
3. **更新最大值：**
    
    - `if(currentCount > count){ count = currentCount; }`
        
    - 这个步骤就是常见的比较并更新最大值操作。
        

### 2. 问题所在

您的代码在**逻辑上是完全正确的，但存在效率问题**。

问题出在`for`循环和第一个`while`循环的组合上。您遍历了数组中的每一个数字，并且**对每一个数字都执行了寻找序列起点和计算长度的操作**。

举个例子：`nums = [4, 5, 6, 1, 2, 3]`

- 当外层循环遍历到 `nums[i] = 4` 时，第一个 `while` 循环会找到起点 `1`，然后第二个 `while` 循环会计算出长度为 `6`。
    
- 当外层循环遍历到 `nums[i] = 5` 时，第一个 `while` 循环会再次找到起点 `1`，然后第二个 `while` 循环再次计算出长度为 `6`。
    
- 当外层循环遍历到 `nums[i] = 6` 时，第一个 `while` 循环会再次找到起点 `1`，然后第二个 `while` 循环再次计算出长度为 `6`。
    

您可以看到，对于同一个连续序列 `[1, 2, 3, 4, 5, 6]`，您的算法会重复地计算它的长度，这是一种**冗余计算**。

在最坏的情况下（例如 `nums = [1, 2, 3, 4, ..., n]`），您的外层循环会执行 n 次，而每一次都会进行一次或多次内层循环。这导致算法的时间复杂度从题目要求的 O(n) 变成了**最坏情况下的 O(n2)**。

### 3. 修改意见

要将您的代码优化到 O(n) 的时间复杂度，我们只需要一个简单的改动：**只从一个连续序列的起点开始计算其长度**。

如何判断一个数字 x 是一个连续序列的起点呢？

答案是：如果 x - 1 不在哈希表中，那么 x 就是一个连续序列的起点。

修改后的代码思路：

1. 将所有数字存入一个 `HashSet`（`HashSet`比`HashMap`更合适，因为我们只需要知道数字是否存在，而不需要存储索引）。
    
2. 遍历数组中的每一个数字 `num`。
    
3. 在内层循环开始前，首先判断**`set.contains(num - 1)` 是否为假**。
    
4. 如果为假（即 `num-1` 不存在），说明 `num` 是一个连续序列的起点，我们才开始计算这个序列的长度。
    
5. 如果为真（即 `num-1` 存在），说明 `num` 只是某个更长的连续序列中间的一个数字，我们**直接跳过**，因为它所在的序列会在其起点被计算。
    

以下是修改后的代码：

Java

```java
import java.util.HashSet;
import java.util.Set;

class Solution {
    public int longestConsecutive(int[] nums) {
        if (nums == null || nums.length == 0) {
            return 0;
        }

        Set<Integer> numSet = new HashSet<>();
        for (int num : nums) {
            numSet.add(num);
        }

        int longestStreak = 0;

        for (int num : numSet) { // 遍历哈希集合更方便
            // 优化点：只从序列的起点开始计算
            // 一个数字是起点的条件是：num - 1 不在哈希集合中
            if (!numSet.contains(num - 1)) {
                int currentNum = num;
                int currentStreak = 1;

                // 找到起点后，向后查找并计算长度
                while (numSet.contains(currentNum + 1)) {
                    currentNum++;
                    currentStreak++;
                }

                longestStreak = Math.max(longestStreak, currentStreak);
            }
        }

        return longestStreak;
    }
}
```

**时间复杂度分析：**

- 将所有数字存入 `Set` 需要 O(n) 时间。
    
- 外层 `for` 循环遍历了每个数字。
    
- `if (!numSet.contains(num - 1))` 这个判断确保了内层 `while` 循环**只会对每个连续序列的起点执行一次**。
    
- 虽然看起来有两个嵌套循环，但每个数字 `num` 都只会被**外层循环访问一次**，并且在**内层 `while` 循环中最多被访问一次**（当它属于某个序列时）。因此，总体的操作次数与 `n` 成正比，时间复杂度是**O(n)**。
    

# 问题汇总

这个算法之所以要遍历`hashset`而不是原始数组`nums`，主要有以下两个关键原因：

### 1. 解决重复元素问题（问题核心）

题目要求的是最长**连续序列**的长度。一个连续序列是由一系列**不同的**整数构成的。例如，如果输入数组是 `[1, 2, 2, 3, 4]`，最长连续序列是 `[1, 2, 3, 4]`，其长度为4。重复出现的数字（如两个`2`）并不会增加序列的长度。

`HashSet`的天然去重特性正好满足了这个要求。它保证了我们处理的每一个数字都是唯一的，从而正确地计算连续序列的长度。遍历`hashset`意味着我们只会对每一个**唯一的数字**进行一次处理，这正是我们需要的。

### 2. 算法效率的根本（O(N)时间复杂度的秘密）

如果遍历原始数组nums，会有什么问题？让我们用一个例子来分析：

假设nums = [100, 4, 200, 1, 3, 2]

1. **创建HashSet:** `hashset = {1, 2, 3, 4, 100, 200}`。
    
2. **开始遍历`hashset`：**
    
    - 当`num`是**1**时：
        
        - `hashset.contains(1 - 1)`，即`hashset.contains(0)`，结果是`false`。
            
        - 这表明`1`是一个潜在的序列起点。
            
        - 进入`while`循环，查找`2, 3, 4`...
            
        - 找到`1, 2, 3, 4`，当前长度为4。更新`resMax = 4`。
            
    - 当`num`是**2**时：
        
        - `hashset.contains(2 - 1)`，即`hashset.contains(1)`，结果是`true`。
            
        - 这表明`2`不是一个序列的起点，它已经是以`1`为起点的序列的一部分。
            
        - **算法跳过对`2`的后续处理。**
            
    - 当`num`是**3**时：
        
        - `hashset.contains(3 - 1)`，即`hashset.contains(2)`，结果是`true`。
            
        - **算法跳过对`3`的后续处理。**
            
    - 当`num`是**4**时：
        
        - `hashset.contains(4 - 1)`，即`hashset.contains(3)`，结果是`true`。
            
        - **算法跳过对`4`的后续处理。**
            
    - ...以此类推，当`num`是`100`和`200`时，它们是各自序列的起点，会被处理。
        

**关键点在于：** `if(! hashset.contains(num - 1))`这个检查。它利用了哈希集合O(1)的查找效率，确保我们只从每个连续序列的**起点**开始计算长度。对于序列中的**非起点**元素（如2, 3, 4），算法会立即跳过，避免重复计算。

如果遍历原始数组`nums`，并且数组中有重复元素，例如`[1, 2, 2, 3, 4]`，虽然`hashset`已经去重了，但如果遍历`nums`，我们可能会多次触发对同一个数字的检查，这会带来不必要的开销（尽管在这个特定算法中，因为`hashset`的检查逻辑，影响可能不大，但从设计上，遍历去重后的集合更清晰和高效）。

**总结：**

- **为什么用`hashset`？** `HashSet`提供了O(1)的平均时间复杂度来检查一个元素是否存在，这是实现O(N)算法的关键。
    
- 为什么遍历hashset？ 1. 天然处理了题目中连续序列中元素唯一的特性。
    
    2. 与if(!hashset.contains(num - 1))结合，保证了每个连续序列只被计算一次，从它的起点开始。这避免了对序列中每个元素都进行一次完整计算，从而将总时间复杂度从理论上的O(N2)优化到了O(N)。
    

所以，遍历`hashset`是这个算法正确性和高效率的根本保障。