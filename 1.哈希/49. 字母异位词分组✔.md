# 题目概述

给你一个字符串数组，请你将 **字母异位词** 组合在一起。可以按任意顺序返回结果列表。

**字母异位词** 指字母相同，但排列不同的字符串。例如，"eat", "tea", "ate" 是彼此的字母异位词。

**输入：** `strs = ["eat", "tea", "tan", "ate", "nat", "bat"]`  
**输出：** `[["bat"],["nat","tan"],["ate","eat","tea"]]`

---

# 解题思路

字母异位词的核心特点是：**如果两个字符串互为字母异位词，那么它们所包含的字母及其数量是完全相同的。**

基于这个特点，我们可以用两种方法作为分组的“键”（Key）：

1. **排序法（最直观）**：

- 对于每个字符串，将其转换为字符数组并 **排序**（例如 "eat" -> "aet", "tea" -> "aet"）。
- 如果是字母异位词，排序后的字符串一定相同。
- 我们可以使用一个 **哈希表 (HashMap)**，`Key` 是排序后的字符串，`Value` 是原字符串的列表。
- 遍历数组，将每个字符串按排序后的 Key 放入对应的 Value 列表中。

2. **计数法（稍快，避免排序）**：

- 既然字母相同，我们可以统计每个字母出现的次数（例如 a:1, e:1, t:1）。
- 将这个统计结果（比如用 `#1#0#0#0...` 这样的字符串或者一个大小为 26 的数组）作为 Key。
- 同样使用 HashMap 进行分组。

这里推荐使用 **排序法**，因为它代码简洁且易于理解，在字符串长度不长的情况下性能也很好（排序复杂度 `O(K log K)`，总复杂度 `O(NK log K)`）。

---

# Java 代码

```Java
import java.util.*;

class Solution {
    public List<List<String>> groupAnagrams(String[] strs) {
        if (strs == null || strs.length == 0) {
            return new ArrayList<>();
        }

        // 使用 HashMap 来分组
        // Key: 排序后的字符串 (代表这一组的特征)
        // Value: 原始字符串列表
        Map<String, List<String>> map = new HashMap<>();

        for (String str : strs) {
            // 1. 将字符串转换为字符数组并排序
            char[] chars = str.toCharArray();
            Arrays.sort(chars);
            
            // 2. 将排序后的字符数组转回字符串作为 Key
            String key = new String(chars);

            // 3. 将原字符串加入对应的列表中
            // computeIfAbsent: 如果 Key 不存在，就创建一个新的 ArrayList，然后添加 str
            map.computeIfAbsent(key, k -> new ArrayList<>()).add(str);
        }

        // 返回 Map 中所有的 Values
        return new ArrayList<>(map.values());
    }
}
```