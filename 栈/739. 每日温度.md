

# 思路
暴力思路：通过47 / 48 个通过的测试用例，超时
```java
class Solution {

    public int[] dailyTemperatures(int[] temperatures) {

        int len = temperatures.length;

        int[] ans = new int[len];

        for(int i = 0; i < len; i ++){

            int num = temperatures[i];

            for(int j = i; j < len; j ++){

                if(temperatures[j] > num){

                    ans[i] = j - i ;

                    break;

                }

            }

        }

        return ans;

    }

}
```

# 优化（单调栈）

### 你现有代码的分析

你的解法使用了双层循环：

- **外层循环**：遍历每一天的温度 `temperatures[i]`。
    
- **内层循环**：从当前天 `i` 开始向后查找，找到第一个比 `temperatures[i]` 更高的温度 `temperatures[j]`，然后计算天数差 `j - i`。
    

**存在的问题：**

- **时间复杂度过高**：在最坏的情况下，例如当温度数组是单调递减的 `[89, 88, 87, ...]`，内层循环对于每个元素都需要遍历到数组末尾。这导致时间复杂度为 **O(n²)**，其中 n 是数组的长度。当数据量很大时，会导致超时。
    
- **重复计算**：该算法没有利用之前遍历过的信息。对于每一个元素，它都重新向后扫描，做了很多重复的工作。
    

### 优化思路：单调栈

这道题是“寻找下一个更大元素”问题的典型变种，最优的解法是使用**单调栈**。

什么是单调栈？

单调栈是一种特殊的栈，它在任何时候都保持栈内元素的单调性（单调递增或单调递减）。

**在本题中的应用思路：**

我们可以维护一个“单调递减”的栈，栈中存储的是数组的**索引**，而不是温度值。这个栈从栈底到栈顶，对应的温度是严格单调递减的。

我们从左到右遍历整个温度数组：

1. 当栈为空时，直接将当前元素的索引入栈。
    
2. 当栈不为空时，将当前温度 `temperatures[i]` 与栈顶索引对应的温度 `temperatures[stack.peek()]` 进行比较。
    
    - **如果当前温度 > 栈顶温度**：说明我们找到了栈顶索引所对应那一天“下一个更暖和的天气”。此时，我们将栈顶索引弹出，并计算天数差 `i - stack.pop()`，存入结果数组。然后，继续将当前温度与新的栈顶温度比较，重复此过程直到当前温度不再大于栈顶温度。
        
    - **如果当前温度 <= 栈顶温度**：说明对于当前温度 `i` 来说，它无法成为栈顶元素的“下一个更大值”。因为我们维护的是单调递减栈，所以直接将当前索引 `i` 入栈，保持栈的单调性。
        

遍历结束后，如果栈中还有剩余的索引，说明这些天之后再也没有更暖和的天了，它们的结果保持默认值 `0` 即可。

### 优化后的代码实现

Java

```java
import java.util.ArrayDeque;
import java.util.Deque;

class Solution {
    public int[] dailyTemperatures(int[] temperatures) {
        int len = temperatures.length;
        int[] ans = new int[len];
        // Deque (双端队列) 是官方推荐用来实现栈的数据结构
        // 栈中存储的是数组的索引
        Deque<Integer> stack = new ArrayDeque<>();



        for (int i = 0; i < len; i++) {
            // 当栈不为空，且当前温度大于栈顶索引对应的温度时
            while (!stack.isEmpty() && temperatures[i] > temperatures[stack.peek()]) {
                // 弹出栈顶索引
                int prevIndex = stack.pop();
                // 计算天数差，并记录在结果数组中
                ans[prevIndex] = i - prevIndex;
            }
            // 将当前索引压入栈中
            stack.push(i);
        }
        return ans;
    }
}
```

### 算法图解

我们以来 `temperatures = [73, 74, 75, 71, 69, 72, 76]` 为例：

1. `i = 0`, `temp = 73`。栈为空，`0` 入栈。 `stack: [0]`
    
2. `i = 1`, `temp = 74`。`74 > temperatures[0](73)`，`0` 出栈，`ans[0] = 1-0 = 1`。`1` 入栈。 `stack: [1]`
    
3. `i = 2`, `temp = 75`。`75 > temperatures[1](74)`，`1` 出栈，`ans[1] = 2-1 = 1`。`2` 入栈。 `stack: [2]`
    
4. `i = 3`, `temp = 71`。`71 < temperatures[2](75)`，`3` 入栈。 `stack: [2, 3]`
    
5. `i = 4`, `temp = 69`。`69 < temperatures[3](71)`，`4` 入栈。 `stack: [2, 3, 4]`
    
6. `i = 5`, `temp = 72`。
    
    - `72 > temperatures[4](69)`，`4` 出栈，`ans[4] = 5-4 = 1`。
        
    - `72 > temperatures[3](71)`，`3` 出栈，`ans[3] = 5-3 = 2`。
        
    - `72 < temperatures[2](75)`，停止比较，`5` 入栈。 `stack: [2, 5]`
        
7. `i = 6`, `temp = 76`。
    
    - `76 > temperatures[5](72)`，`5` 出栈，`ans[5] = 6-5 = 1`。
        
    - `76 > temperatures[2](75)`，`2` 出栈，`ans[2] = 6-2 = 4`。
        
    - `6` 入栈。 `stack: [6]`
        

循环结束，`ans = [1, 1, 4, 2, 1, 1, 0]`。

### 优化效果总结

- **时间复杂度**：**O(n)**。因为数组中的每个元素最多入栈一次、出栈一次，所以总的操作次数与数组长度成正比。
    
- **空间复杂度**：**O(n)**。在最坏的情况下（例如单调递减的数组），所有元素的索引都会被压入栈中。
    

通过使用单调栈，我们将算法的性能从平方级别 **O(n²)** 优化到了线性级别 **O(n)**，这是一个巨大的提升。

[Queue和Deque](../../../backend/javase/Queue和Deque.md)