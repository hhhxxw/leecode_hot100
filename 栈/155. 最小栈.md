# 思路
我明白题目的意思，但是我看不动他的输入输出
```java
class MinStack {

    int min = 2^31 - 1;

    public MinStack() {

       Deque<Integer> stk = new ArrayDeque<>();

    }

    public void push(int val) {

        if(val < min){

            min = val;

        }

        stk.push(val);

    }

    public void pop() {

        stk.pop();

    }

    public int top() {

        return stk.top();

    }

    public int getMin() {  

        return min;

    }

}

  

/**

 * Your MinStack object will be instantiated and called as such:

 * MinStack obj = new MinStack();

 * obj.push(val);

 * obj.pop();

 * int param_3 = obj.top();

 * int param_4 = obj.getMin();

 */
```
# 提示词
```
# 角色和目标

你好，请你扮演一位资深的Java开发工程师，同时也是一位擅长讲解算法的导师。

我的目标是彻底理解力扣155. 最小栈的这道题目，并学习解决这类问题的通用思路。请你以一个初级Java程序员能完全听懂的方式，为我提供详细的指导。

# 题目

155. 最小栈， 理解题目含义，样例输入输出

# 我的思路

class MinStack {

    int min = 2^31 - 1;

    public MinStack() {

       Deque<Integer> stk = new ArrayDeque<>();

    }

    public void push(int val) {

        if(val < min){

            min = val;

        }

        stk.push(val);

    }

    public void pop() {

        stk.pop();

    }

    public int top() {

        return stk.top();

    }

    public int getMin() {  

        return min;

    }

}

# 我的困惑

我明白题目的意思，但是我看不动他的输入输出

# 我希望的输出

请你根据以上信息，为我提供一份详细的题解，并满足以下要求：

1. 思路讲解：首先，请确认我的思路是否正确。然后，用通俗易懂的语言，分步骤详细讲解正确的解题思路，特别是针对我的困惑点进行解答。

2. 数据结构选择：选择合适的数据结构，并讲解为什么使用该数据结构

3. Java代码实现：提供一份完整、可运行的Java代码。 

4. 代码注释： 请在代码的关键部分加上详细的注释，解释这行代码（或代码块）的作用，让我能逐行理解。 

5. 复杂度分析： 在代码之后，请分析该算法的时间复杂度和空间复杂度。

6. 给出leecode相同思路的题目

7. 给出的笔记符合obsidian格式，并美化格式
```

你好！很高兴能以你资深Java导师的身份，和你一起攻克这道非常巧妙的“最小栈”问题。

首先，你的思路非常敏锐，尝试用一个变量 `min` 来实时追踪最小值，这是一个很好的起点。你的代码没能通过，不是因为思路大方向有错，而是因为忽略了 `pop` 操作带来的一个“致命”问题。同时，你的困惑点——看不懂输入输出——也是初学者在接触这类“设计题”时非常常见的疑问。

别担心，我们今天就把这些问题一网打尽！

---

# 🚀 LeetCode 155. 最小栈 - 空间换时间的经典范式

> [!NOTE] 题目要求
> 
> 设计一个栈，除了支持常规的 push、pop、top 操作外，还支持在一个常数时间 O(1) 内检索到栈中的最小元素。

---

## 1. 思路讲解

### a. 解决你的困惑：如何理解输入输出？

> [!TIP] LeetCode的“设计题”测试方式
> 
> 对于“最小栈”这类题目，LeetCode的测试系统不是给你一个输入，让你返回一个输出。而是像下面这样，模拟一个用户在调用你写的 MinStack 类：
> 
> 1. `MinStack minStack = new MinStack();` (创建一个你的栈对象)
>     
> 2. `minStack.push(-2);` (调用push方法)
>     
> 3. `minStack.push(0);` (调用push方法)
>     
> 4. `minStack.push(-3);` (调用push方法)
>     
> 5. `minStack.getMin();` (调用getMin，**期望返回 -3**)
>     
> 6. `minStack.pop();` (调用pop方法)
>     
> 7. `minStack.top();` (调用top，**期望返回 0**)
>     
> 8. `minStack.getMin();` (调用getMin，**期望返回 -2**)
>     
> 
> LeetCode会执行这一系列操作，并检查你在每一步的返回值是否符合预期。

### b. 你的思路为什么不完全正确？

你的思路是用一个变量 `min` 来记录全局最小值。这个想法在 `push` 时是没问题的，但它有一个**致命缺陷**。

> [!bug] Bug分析：当最小值被弹出时
> 
> 让我们模拟一下上面的操作序列：
> 
> 1. `push(-2)`: `min` 变为 -2。 栈: `[-2]`
>     
> 2. `push(0)`: `min` 仍为 -2。 栈: `[-2, 0]`
>     
> 3. `push(-3)`: `min` 变为 -3。 栈: `[-2, 0, -3]`
>     
> 4. `getMin()`: 返回 `min`，即 **-3**。正确。
>     
> 5. `pop()`: 栈顶的 `-3` 被弹出。 栈: `[-2, 0]`
>     
> 6. `getMin()`: 再次调用，返回 `min`。**此时 `min` 变量的值仍然是 -3！**
>     
> 
> **问题出现了**：栈里现在的最小值应该是 **-2**，但你的程序仍然会错误地返回 `-3`。因为当 `-3` 被弹出后，你没有一个机制去**“回忆”**起 `-3` 入栈之前的那个最小值（也就是-2）是什么。

### c. 正确的解题思路：请个“小助理”——辅助栈

> [!SUCCESS] 核心思想
> 
> 我们需要一个方法，能在 pop 之后，立刻知道栈中剩下的元素的最小值是什么。
> 
> 解决方案就是：再创建一个栈，我们称之为“**辅助栈**” (`minStack`)。这个栈不存所有元素，它只负责一件事：**记录每一步操作后，主栈中的最小值是什么**。

**这个“小助理”的工作方式如下：**

- **`push(val)` 操作时：**
    
    1. `val` 正常压入**主栈** (`dataStack`)。
        
    2. 比较 `val` 和**辅助栈**的**栈顶元素**。
        
    3. 将**较小**的那个值，压入**辅助栈**。
        
        - （如果辅助栈为空，直接将 `val` 压入）
            
- **`pop()` 操作时：**
    
    1. **主栈**弹出一个元素。
        
    2. **辅助栈也必须同步弹出一个元素！** 这样，辅助栈的栈顶就永远对应着主栈当前状态下的最小值。
        
- **`getMin()` 操作时：**
    
    - 我们根本不用关心主栈里有什么，直接 `peek()` 一下**辅助栈的栈顶**，那里永远保存着我们想要的答案！
        

#### 可视化这个过程

|操作|`dataStack` (主栈)|`minStack` (辅助栈)|`getMin()` 返回|
|---|---|---|---|
|**`push(-2)`**|`[-2]`|`[-2]`|-|
|**`push(0)`**|`[-2, 0]`|`[-2, -2]` (因为-2 < 0)|-|
|**`push(-3)`**|`[-2, 0, -3]`|`[-2, -2, -3]` (因为-3 < -2)|-|
|**`getMin()`**|`[-2, 0, -3]`|`[-2, -2, -3]`|**-3** (辅助栈顶)|
|**`pop()`**|`[-2, 0]`|`[-2, -2]` (同步弹出)|-|
|**`getMin()`**|`[-2, 0]`|`[-2, -2]`|**-2** (新的辅助栈顶)|

你看，通过这个简单的同步机制，我们完美地解决了 `pop` 操作带来的问题，并且 `getMin` 始终是 O(1) 的。

---

## 2. 数据结构选择 🛠️

- **`Deque<Integer> dataStack`**: 用作主栈，存储所有压入的元素。我们使用 `Deque` 接口及其实现 `ArrayDeque`，这是Java中实现栈功能的推荐方式。
    
- **`Deque<Integer> minStack`**: 用作辅助栈，同步记录每一步的最小值。
    

---

## 3. Java 代码实现与注释

Java

```java
import java.util.ArrayDeque;
import java.util.Deque;

class MinStack {

    // 主栈，用于存储所有元素
    private Deque<Integer> dataStack;
    // 辅助栈，栈顶永远是主栈所有元素的最小值
    private Deque<Integer> minStack;

    /** initialize your data structure here. */
    public MinStack() {
        // 在构造函数中初始化两个栈
        dataStack = new ArrayDeque<>();
        minStack = new ArrayDeque<>();
    }
    
    public void push(int val) {
        // 1. 主栈直接压入元素
        dataStack.push(val);
        
        // 2. 辅助栈进行判断
        if (minStack.isEmpty() || val <= minStack.peek()) {
            // 如果辅助栈为空，或者新元素小于等于当前最小值，
            // 则将新元素也压入辅助栈。
            // (使用 <= 是为了处理有重复最小值的情况)
            minStack.push(val);
        } else {
            // 如果新元素大于当前最小值，
            // 则再次将当前最小值压入辅助栈，以保持与主栈元素个数同步。
            minStack.push(minStack.peek());
        }
    }
    
    public void pop() {
        // 两个栈必须同时弹出，以保持状态同步
        dataStack.pop();
        minStack.pop();
    }
    
    public int top() {
        // top 操作只关心主栈的栈顶
        return dataStack.peek();
    }
    
    public int getMin() {
        // getMin 操作只关心辅助栈的栈顶
        return minStack.peek();
    }
}

/**
 * Your MinStack object will be instantiated and called as such:
 * MinStack obj = new MinStack();
 * obj.push(val);
 * obj.pop();
 * int param_3 = obj.top();
 * int param_4 = obj.getMin();
 */
```

---

## 4. 复杂度分析

- **时间复杂度：O(1)**
    
    - `push`, `pop`, `top`, `getMin` 这四个操作，都只涉及对栈顶的常数次操作，所以时间复杂度都是 O(1)。完美符合题目要求。
        
- **空间复杂度：O(N)**
    
    - N 是栈中元素的数量。
        
    - 我们需要一个主栈和一个辅助栈，它们的大小都与存入的元素数量成正比。
        

---

## 5. 触类旁通：栈的“全家桶”

> [!SUCCESS] 掌握了“辅助栈”这种“空间换时间”的思想，你可以挑战：
> 
> - [[20. 有效的括号]]: 栈的基础应用，用于匹配。
>     
> - [[739. 每日温度]]: 经典的“单调栈”问题，寻找下一个更大的元素。
>     
> - [[150. 逆波兰表达式求值]]: 用栈来处理后缀表达式的计算。
>     

希望这份从诊断错误到最终方案的详细讲解，能让你彻底掌握这道题，并对如何利用辅助数据结构来优化算法有更深的理解！