> 看到“有序”，要想到使用二分

# 红蓝染色法

> 内容：开区间、半开半闭区间、开区间的写法->如何处理>=、 >、 <、 <=这四种情况->最后解决[34. 在排序数组中查找元素的第一个和最后一个位置](https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/)这道题目




![](img/Pasted%20image%2020250815154401.png)

![](img/Pasted%20image%2020250815154024.png)
## AI总结
---

### 吃透二分查找

#### `1. 核心思想：蓝红染色法`

让我们先从你提供的图片开始，它揭示了一种非常直观且强大的二分查找变体思维模型——**蓝红染色法**。

想象一个数组，我们根据一个特定的 `target` 值，可以将数组中的元素分成两个部分：

- **蓝色部分**：满足某个条件的元素（例如 `≥ target`）。
    
- **红色部分**：不满足该条件的元素（例如 `< target`）。
    

由于数组是**有序**的，那么这个数组就会被 `target` 分成一个清晰的“红蓝边界”。

![](img/Pasted%20image%2020250815152949.png)

**二分查找的目标，就是精确地找到这个红蓝边界点。**

#### `2. 两种边界与代码模板`

根据你要找的是“蓝色部分的左边界”还是“红色部分的右边界”，我们可以归纳出两种主要的二分查找模板。

##### 模板一：寻找蓝色部分的左边界 (>= target 的第一个元素)

这个模板可以解决的问题包括：

- 寻找 `target` 第一次出现的位置。
    
- 寻找第一个大于等于 `target` 的元素。
    

**分析过程：**

1. **初始化**：`L = 0`, `R = n-1` (n 为数组长度)。`ans` (答案) 初始化为一个特殊值，比如 `n` 或 `-1`。
    
2. **循环条件**：`L <= R`
    
3. **计算中点**：`M = L + (R - L) / 2` (这样写可以防止整数溢出)
    
4. **判断 `nums[M]`**：
    
    - 如果 `nums[M] >= target` (染成蓝色)：
        
        - 说明 `M` 以及 `M` 右边的所有元素都是“蓝色”的。
            
        - `M` **有可能**是我们要找的第一个蓝色元素，所以我们用 `ans` 把它存下来：`ans = M`。
            
        - 但我们还要继续向**左边**探索，看看有没有更靠左的蓝色元素：`R = M - 1`。
            
    - 如果 `nums[M] < target` (染成红色)：
        
        - 说明 `M` 以及 `M` 左边的所有元素都是“红色”的，肯定不是答案。
            
        - 我们需要向**右边**寻找蓝色区域：`L = M + 1`。
            
5. **返回结果**：循环结束后，`ans` 中存储的就是最终答案。
    

##### 模板二：寻找红色部分的右边界 (< target 的最后一个元素)

这个模板可以解决的问题包括：

- 寻找 `target` 最后一次出现的位置 (稍微变形)。
    
- 寻找最后一个小于 `target` 的元素。
    

**分析过程:**

1. **初始化**：`L = 0`, `R = n-1`, `ans = -1`。
    
2. **循环条件**：`L <= R`
    
3. **计算中点**：`M = L + (R - L) / 2`
    
4. **判断 `nums[M]`**：
    
    - 如果 `nums[M] < target` (染成红色)：
        
        - 说明 `M` 是一个“红色”元素。
            
        - `M` **有可能**是我们要找的最后一个红色元素，记录下来：`ans = M`。
            
        - 我们还要继续向**右边**探索，看看有没有更靠右的红色元素：`L = M + 1`。
            
    - 如果 `nums[M] >= target` (染成蓝色)：
        
        - 说明 `M` 以及 `M` 右边的所有元素都是“蓝色”的，肯定不是答案。
            
        - 我们需要向**左边**寻找红色区域：`R = M - 1`。
            
5. **返回结果**：循环结束后，`ans` 就是答案。
    

> **发散思维**：
> 
> - **为什么是 `L <= R`?**
>     
>     - 这个条件保证了当 `L` 和 `R` 相遇时，这个位置的元素仍然会被检查。如果写成 `L < R`，当 `L` 和 `R` 相邻时，`M` 会与 `L` 重合，一旦 `L` 被更新为 `M+1`，循环就会终止，`R` 指向的那个元素就会被错过。
>         
> - **区间的开闭**：
>     
>     - 上面的模板我们都使用 `[L, R]` 闭区间，这是最直观、最不容易出错的写法。也有一些人习惯用 `[L, R)` 左闭右开区间，那样的写法在 `R` 的初始化和循环条件上会略有不同，但核心思想不变。对于初学者，**强烈推荐先熟练掌握闭区间写法**。
>         

---

#### `3. 实战演练：LeetCode 34`

现在，我们用学到的“蓝红染色法”来解决这个问题。

> 问题描述:
> 
> 给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。
> 
> 如果数组中不存在目标值，返回 [-1, -1]。
> 
> 示例:
> 
> 输入: nums = [5, 7, 7, 8, 8, 10], target = 8
> 
> 输出: [3, 4]

##### 解题思路

这个问题可以完美地拆分成两个子问题：

1. **寻找第一个 `8`**：这等价于寻找“蓝色部分的左边界”，条件是 `nums[i] >= 8`。
    
2. **寻找最后一个 `8`**：这可以等价于寻找“**第一个** `> 8` 的元素的位置，再减 `1`”。也就是寻找 `target + 1` 的左边界，然后将结果左移一位。
    

我们来一步步分解：

##### `3.1 寻找开始位置 (第一个 >= target 的位置)`

- **染色条件**: `nums[i] >= target` 的为蓝色，`< target` 的为红色。
    
- **目标**: 蓝色区域的左边界。
    
- **套用模板一**:
    

Python

```python
def find_first_position(nums, target):
    L, R = 0, len(nums) - 1
    ans = -1
    while L <= R:
        M = L + (R - L) // 2
        if nums[M] >= target:
            # 找到一个潜在的答案，继续向左缩小范围
            ans = M
            R = M - 1
        else:
            # 当前值太小，向右寻找
            L = M + 1
    # 循环结束后，需要验证找到的 ans 是否真的等于 target
    # 如果 ans 是 -1 或者 nums[ans] 不等于 target，说明不存在
    if ans == -1 or nums[ans] != target:
        return -1
    return ans

```

**对于 `[5, 7, 7, 8, 8, 10]` 和 `target = 8`：**

1. `L=0, R=5, M=2`, `nums[2]=7 < 8`, `L` 变成 `3`。
    
2. `L=3, R=5, M=4`, `nums[4]=8 >= 8`, `ans` 存 `4`，`R` 变成 `3`。
    
3. `L=3, R=3, M=3`, `nums[3]=8 >= 8`, `ans` 存 `3`，`R` 变成 `2`。
    
4. `L=3, R=2`, 循环结束。
    
5. 返回 `ans = 3`。验证 `nums[3] == 8`，正确！
    
> 思考R = M - 1这里是为什么，而不是R = M，我知道了，他是为了找到第一个>=target的数字，所以找到后面等于target的数字还是要往不满足条件的部分缩小空间
##### `3.2 寻找结束位置 (第一个 > target 的位置 - 1)`

- **染色条件**: `nums[i] > target` 的为蓝色，`<= target` 的为红色。
    
- **目标**: 蓝色区域的左边界。
    
- **套用模板一** (只需改动判断条件):
    

Python

```python
def find_first_greater_position(nums, target):
    L, R = 0, len(nums) - 1
    ans = len(nums) # 初始化为数组长度，这是一个哨兵值
    while L <= R:
        M = L + (R - L) // 2
        if nums[M] > target:
            # 找到一个潜在的答案，继续向左缩小范围
            ans = M
            R = M - 1
        else:
            # 当前值不够大，向右寻找
            L = M + 1
    return ans
```

**对于 `[5, 7, 7, 8, 8, 10]` 和 `target = 8`：**

1. `find_first_greater_position` 会找到第一个大于 `8` 的数，也就是 `10`，其索引是 `5`。
    
2. 那么最后一个 `8` 的索引就是 `5 - 1 = 4`。
    

##### `3.3 组合与最终代码`

Python

```python
class Solution:
    def searchRange(self, nums: list[int], target: int) -> list[int]:
        
        # 寻找第一个 >= target 的位置
        def find_first(nums, target):
            L, R = 0, len(nums) - 1
            ans = -1
            while L <= R:
                M = L + (R - L) // 2
                if nums[M] >= target:
                    ans = M
                    R = M - 1
                else:
                    L = M + 1
            return ans

        # 寻找第一个 > target 的位置
        def find_first_greater(nums, target):
            L, R = 0, len(nums) - 1
            ans = len(nums)
            while L <= R:
                M = L + (R - L) // 2
                if nums[M] > target:
                    ans = M
                    R = M - 1
                else:
                    L = M + 1
            return ans

        start = find_first(nums, target)
        
        # 如果 start 是 -1 或者 start 指向的值不等于 target，说明根本不存在
        if start == -1 or nums[start] != target:
            return [-1, -1]
            
        # 寻找结束位置
        end = find_first_greater(nums, target) - 1
        
        return [start, end]

```

---

#### `4. 总结与回顾`

- **核心是单调性**：二分查找能用的前提是数组（或数据范围）具有单调性，这样才能应用“染色法”。
    
- **蓝红染色法**：这是一个强大的思维模型，帮你把问题转化为寻找“边界”。
    
- **确定边界条件**：想清楚你要找的是“第一个 >= target”还是“最后一个 <= target”等，这决定了你的 `if` 判断条件和 `L`, `R` 的移动策略。
    
- **闭区间模板 (`L<=R`)**：对初学者最友好，通过改变 `if` 里的判断和后续的指针移动，可以解决几乎所有二分查找问题。
    

希望这份笔记能帮你建立起对二分查找清晰而深刻的理解！记住，多在 LeetCode 上找相关题目练习，才能真正将模板内化于心。祝你刷题愉快！

----

很多初学者把二分搜索死记硬背成“在一个有序数组里找特定值”，但它的威力远不止于此。今天，我们就以这张图为“心法秘籍”，彻底掌握二分搜索的本质，并用它来轻松解决“寻找峰值”这道题。

---

# 🚀 二分搜索的终极奥义：从“红蓝染色”到“万能模板”

> [!QUOTE] 核心思想
> 
> 二分搜索的本质，不是在“序列”中搜索，而是在一个具有单调性的“性质”中，寻找那个从 false 变为 true 的临界点。

---

## 1. 剖析“心法秘籍”：图中的红蓝染色法

你提供的图片，用一种极其优雅的方式，揭示了二分搜索的本质。

> [!NOTE] 红蓝染色法
> 
> 1. **定义一个性质 (Property)**：我们想找到一个“目标峰顶”。定义了一个性质：“**当前位置是否在目标峰顶及其右侧？**”
>     
> 2. **染色**：
>     
>     - 不满足该性质的区域（在峰顶左侧，即“上坡路”），染成**红色 (false)**。
>         
>     - 满足该性质的区域（从峰顶开始的“下坡路”），染成**蓝色 (true)**。
>         
> 3. **二分**：我们的任务，就是通过不断地在中间位置“取样”并判断其颜色，来快速找到**第一个蓝色点**的位置。
>     

|1|2|1|2|4|3|6|
|---|---|---|---|---|---|---|
|<span style="background-color: #ffcccc;">红色</span>|<span style="background-color: #ffcccc;">红色</span>|<span style="background-color: #ffcccc;">红色</span>|<span style="background-color: #ffcccc;">红色</span>|<span style="background-color: #ccddff;">蓝色</span>|<span style="background-color: #ccddff;">蓝色</span>|<span style="background-color: #ccddff;">蓝色</span>|
|**上坡**|**上坡**|**下坡**|**上坡**|**峰顶(下坡开始)**|**下坡**|**上坡**|

等等，这个序列好像不是单调的？

没错！单个元素的值不是单调的，但我们定义的“性质”——坡度的走向——是具有单-调性的。在一个峰值的两侧，必然一边是上坡，一边是下坡。我们可以利用这个坡度信息来二分。

如何判断坡度（颜色）？

图片给出了关键线索：比较 M 和 M+1。

- 如果 `nums[M] < nums[M+1]`：说明 `M` 正处于一段**上坡路**。我们想找的峰顶一定在它的**右边**。所以 `M` 是**红色**的。
    
- 如果 `nums[M] > nums[M+1]`：说明 `M` 正处于一段**下坡路**。`M` **本身可能就是峰顶**，或者峰顶在它的**左边**。所以 `M` 是**蓝色**的。


这里第二个元素为什么是红色的？nums[1] > nums[2], 所以第二个元素应该是蓝色才对啊
    

---

## 2. 提炼“万能模板”：解决一类二分问题

> [!abstract] 任何可以用二分解决的问题，都可以套用以下三步思考法：

**第一步：定义 `check(i)` 函数**

> 这是最关键的一步！你需要把问题转化为一个返回 `true/false` 的判断函数 `check(i)`，并且这个函数在整个搜索区间上必须呈现出**单调性**（即一段连续的 `false` 跟着一段连续的 `true`，或者反之）。

**第二步：确定搜索区间**

> 明确你的答案可能存在的范围 `[left, right]`。

**第三步：套用二分模板**

> 根据你的 `check(i)` 函数，选择合适的模板来收缩区间，最终找到那个 `false` 和 `true` 的分界点。

一个非常通用的“**寻找左边界**”（即第一个 `true` 的位置）的模板如下：

Java

```java
int left = 0, right = ...;
while (left < right) {
    int mid = left + (right - left) / 2;
    if (check(mid)) { // 如果 mid 是蓝色
        right = mid; // 答案可能是 mid，或者在 mid 左边，所以 right = mid
    } else { // 如果 mid 是红色
        left = mid + 1; // mid 肯定不是答案，所以从 mid + 1 开始找
    }
}
return left; // 或 right，此时它们相等
```

---

## 3. 实战演练：用“万能模板”解决 [[162. 寻找峰值]]

> [!SUCCESS] 我们来应用三步法

**第一步：定义 `check(i)` 函数**

- **问题**：寻找一个峰值。
    
- **性质**：峰值是一个“下坡路”的开始。所以，我们可以定义 `check(i)` 为 “**`nums[i]` 是否大于它右边的邻居 `nums[i+1]`**？”
    
- **单调性**：对于任何一个峰值，它左边的上坡路，`check` 函数都返回 `false`；从峰值开始的下坡路，`check` 函数都返回 `true`。完美符合 `false...false, true...true` 的二段性！
    

**第二步：确定搜索区间**

- 数组索引范围是 `[0, n-1]`。但我们的 `check` 函数需要访问 `mid+1`，为了避免越界，我们可以将右边界设为 `n-2`，或者在循环中处理。一个更巧妙的方法是，题目保证了 `nums[-1] = nums[n] = -∞`，这实际上给了我们一个虚拟的边界，让我们的比较逻辑在边界处也成立。
    

**第三步：套用二分模板**

### Java 代码实现与注释

Java

```java
class Solution {
    public int findPeakElement(int[] nums) {
        // 定义搜索区间的左右边界。
        // right 初始化为 n-1，因为峰值可能出现在最后一个位置。
        int left = 0;
        int right = nums.length - 1;

        // 使用 left < right 的模板，最终 left 和 right 会相遇于峰值点。
        while (left < right) {
            // 计算中间位置
            int mid = left + (right - left) / 2;

            // --- 核心判断逻辑，即我们的 check(mid) 函数 ---
            // 比较中间元素和它右边的元素，判断坡度
            if (nums[mid] < nums[mid + 1]) {
                // 如果 mid 元素更小，说明我们正处于一个“上坡”阶段。
                // 峰值一定在右边，所以我们可以安全地舍弃左半部分（包括mid）。
                // 因此，更新左边界。
                left = mid + 1;
            } else { // nums[mid] >= nums[mid + 1]
                // 如果 mid 元素更大或相等，说明我们正处于一个“下坡”阶段。
                // mid 本身可能就是峰值，或者峰值在它的左边。
                // 我们不能舍弃 mid，所以收缩右边界。
                right = mid;
            }
        }

        // 循环结束时，left 和 right 相遇，指向的即为一个峰值。
        return left;
    }
}
```

---

## 4. 复杂度与总结

- **时间复杂度：O(log N)**
    
    - N 是数组的长度。每一次比较，我们都将搜索范围缩小一半。
        
- **空间复杂度：O(1)**
    
    - 只使用了固定的几个变量。
        

> [!TODO] 触类旁通：用此模板解决更多问题
> 
> 掌握了这个“定义性质 -> 二分查找边界”的万能模板后，你可以去挑战：
> 
> - [[153. 寻找旋转排序数组中的最小值]]：`check(i)` 可以定义为 `nums[i] < nums[0]` 吗？
>     
> - [[69. x 的平方根]]：在 `[0, x]` 的答案区间上二分，`check(i)` 定义为 `(long)i * i >= x`。
>     
> - [[875. 爱吃香蕉的珂珂]]：在“速度”的可能范围上二分，`check(speed)` 定义为“以这个速度能否在H小时内吃完所有香蕉？”
>     

希望这份从图片心法到万能模板，再到实战的详细笔记，能让你对二分搜索有一个飞跃式的理解！


# 学习资料
- [灵茶山艾府](https://www.bilibili.com/video/BV1AP41137w7/?vd_source=54291517f0e970812239345528e873cf)
