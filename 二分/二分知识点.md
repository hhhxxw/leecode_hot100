> 看到“有序”，要想到使用二分

# 红蓝染色法

> 内容：开区间、半开半闭区间、开区间的写法->如何处理>=、 >、 <、 <=这四种情况->最后解决[34. 在排序数组中查找元素的第一个和最后一个位置](https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/)这道题目




![](img/Pasted%20image%2020250815154401.png)

![](img/Pasted%20image%2020250815154024.png)
## AI总结
---

### 吃透二分查找

#### `1. 核心思想：蓝红染色法`

让我们先从你提供的图片开始，它揭示了一种非常直观且强大的二分查找变体思维模型——**蓝红染色法**。

想象一个数组，我们根据一个特定的 `target` 值，可以将数组中的元素分成两个部分：

- **蓝色部分**：满足某个条件的元素（例如 `≥ target`）。
    
- **红色部分**：不满足该条件的元素（例如 `< target`）。
    

由于数组是**有序**的，那么这个数组就会被 `target` 分成一个清晰的“红蓝边界”。

![](img/Pasted%20image%2020250815152949.png)

**二分查找的目标，就是精确地找到这个红蓝边界点。**

#### `2. 两种边界与代码模板`

根据你要找的是“蓝色部分的左边界”还是“红色部分的右边界”，我们可以归纳出两种主要的二分查找模板。

##### 模板一：寻找蓝色部分的左边界 (>= target 的第一个元素)

这个模板可以解决的问题包括：

- 寻找 `target` 第一次出现的位置。
    
- 寻找第一个大于等于 `target` 的元素。
    

**分析过程：**

1. **初始化**：`L = 0`, `R = n-1` (n 为数组长度)。`ans` (答案) 初始化为一个特殊值，比如 `n` 或 `-1`。
    
2. **循环条件**：`L <= R`
    
3. **计算中点**：`M = L + (R - L) / 2` (这样写可以防止整数溢出)
    
4. **判断 `nums[M]`**：
    
    - 如果 `nums[M] >= target` (染成蓝色)：
        
        - 说明 `M` 以及 `M` 右边的所有元素都是“蓝色”的。
            
        - `M` **有可能**是我们要找的第一个蓝色元素，所以我们用 `ans` 把它存下来：`ans = M`。
            
        - 但我们还要继续向**左边**探索，看看有没有更靠左的蓝色元素：`R = M - 1`。
            
    - 如果 `nums[M] < target` (染成红色)：
        
        - 说明 `M` 以及 `M` 左边的所有元素都是“红色”的，肯定不是答案。
            
        - 我们需要向**右边**寻找蓝色区域：`L = M + 1`。
            
5. **返回结果**：循环结束后，`ans` 中存储的就是最终答案。
    

##### 模板二：寻找红色部分的右边界 (< target 的最后一个元素)

这个模板可以解决的问题包括：

- 寻找 `target` 最后一次出现的位置 (稍微变形)。
    
- 寻找最后一个小于 `target` 的元素。
    

**分析过程:**

1. **初始化**：`L = 0`, `R = n-1`, `ans = -1`。
    
2. **循环条件**：`L <= R`
    
3. **计算中点**：`M = L + (R - L) / 2`
    
4. **判断 `nums[M]`**：
    
    - 如果 `nums[M] < target` (染成红色)：
        
        - 说明 `M` 是一个“红色”元素。
            
        - `M` **有可能**是我们要找的最后一个红色元素，记录下来：`ans = M`。
            
        - 我们还要继续向**右边**探索，看看有没有更靠右的红色元素：`L = M + 1`。
            
    - 如果 `nums[M] >= target` (染成蓝色)：
        
        - 说明 `M` 以及 `M` 右边的所有元素都是“蓝色”的，肯定不是答案。
            
        - 我们需要向**左边**寻找红色区域：`R = M - 1`。
            
5. **返回结果**：循环结束后，`ans` 就是答案。
    

> **发散思维**：
> 
> - **为什么是 `L <= R`?**
>     
>     - 这个条件保证了当 `L` 和 `R` 相遇时，这个位置的元素仍然会被检查。如果写成 `L < R`，当 `L` 和 `R` 相邻时，`M` 会与 `L` 重合，一旦 `L` 被更新为 `M+1`，循环就会终止，`R` 指向的那个元素就会被错过。
>         
> - **区间的开闭**：
>     
>     - 上面的模板我们都使用 `[L, R]` 闭区间，这是最直观、最不容易出错的写法。也有一些人习惯用 `[L, R)` 左闭右开区间，那样的写法在 `R` 的初始化和循环条件上会略有不同，但核心思想不变。对于初学者，**强烈推荐先熟练掌握闭区间写法**。
>         

---

#### `3. 实战演练：LeetCode 34`

现在，我们用学到的“蓝红染色法”来解决这个问题。

> 问题描述:
> 
> 给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。
> 
> 如果数组中不存在目标值，返回 [-1, -1]。
> 
> 示例:
> 
> 输入: nums = [5, 7, 7, 8, 8, 10], target = 8
> 
> 输出: [3, 4]

##### 解题思路

这个问题可以完美地拆分成两个子问题：

1. **寻找第一个 `8`**：这等价于寻找“蓝色部分的左边界”，条件是 `nums[i] >= 8`。
    
2. **寻找最后一个 `8`**：这可以等价于寻找“**第一个** `> 8` 的元素的位置，再减 `1`”。也就是寻找 `target + 1` 的左边界，然后将结果左移一位。
    

我们来一步步分解：

##### `3.1 寻找开始位置 (第一个 >= target 的位置)`

- **染色条件**: `nums[i] >= target` 的为蓝色，`< target` 的为红色。
    
- **目标**: 蓝色区域的左边界。
    
- **套用模板一**:
    

Python

```python
def find_first_position(nums, target):
    L, R = 0, len(nums) - 1
    ans = -1
    while L <= R:
        M = L + (R - L) // 2
        if nums[M] >= target:
            # 找到一个潜在的答案，继续向左缩小范围
            ans = M
            R = M - 1
        else:
            # 当前值太小，向右寻找
            L = M + 1
    # 循环结束后，需要验证找到的 ans 是否真的等于 target
    # 如果 ans 是 -1 或者 nums[ans] 不等于 target，说明不存在
    if ans == -1 or nums[ans] != target:
        return -1
    return ans

```

**对于 `[5, 7, 7, 8, 8, 10]` 和 `target = 8`：**

1. `L=0, R=5, M=2`, `nums[2]=7 < 8`, `L` 变成 `3`。
    
2. `L=3, R=5, M=4`, `nums[4]=8 >= 8`, `ans` 存 `4`，`R` 变成 `3`。
    
3. `L=3, R=3, M=3`, `nums[3]=8 >= 8`, `ans` 存 `3`，`R` 变成 `2`。
    
4. `L=3, R=2`, 循环结束。
    
5. 返回 `ans = 3`。验证 `nums[3] == 8`，正确！
    
> 思考R = M - 1这里是为什么，而不是R = M，我知道了，他是为了找到第一个>=target的数字，所以找到后面等于target的数字还是要往不满足条件的部分缩小空间
##### `3.2 寻找结束位置 (第一个 > target 的位置 - 1)`

- **染色条件**: `nums[i] > target` 的为蓝色，`<= target` 的为红色。
    
- **目标**: 蓝色区域的左边界。
    
- **套用模板一** (只需改动判断条件):
    

Python

```python
def find_first_greater_position(nums, target):
    L, R = 0, len(nums) - 1
    ans = len(nums) # 初始化为数组长度，这是一个哨兵值
    while L <= R:
        M = L + (R - L) // 2
        if nums[M] > target:
            # 找到一个潜在的答案，继续向左缩小范围
            ans = M
            R = M - 1
        else:
            # 当前值不够大，向右寻找
            L = M + 1
    return ans
```

**对于 `[5, 7, 7, 8, 8, 10]` 和 `target = 8`：**

1. `find_first_greater_position` 会找到第一个大于 `8` 的数，也就是 `10`，其索引是 `5`。
    
2. 那么最后一个 `8` 的索引就是 `5 - 1 = 4`。
    

##### `3.3 组合与最终代码`

Python

```python
class Solution:
    def searchRange(self, nums: list[int], target: int) -> list[int]:
        
        # 寻找第一个 >= target 的位置
        def find_first(nums, target):
            L, R = 0, len(nums) - 1
            ans = -1
            while L <= R:
                M = L + (R - L) // 2
                if nums[M] >= target:
                    ans = M
                    R = M - 1
                else:
                    L = M + 1
            return ans

        # 寻找第一个 > target 的位置
        def find_first_greater(nums, target):
            L, R = 0, len(nums) - 1
            ans = len(nums)
            while L <= R:
                M = L + (R - L) // 2
                if nums[M] > target:
                    ans = M
                    R = M - 1
                else:
                    L = M + 1
            return ans

        start = find_first(nums, target)
        
        # 如果 start 是 -1 或者 start 指向的值不等于 target，说明根本不存在
        if start == -1 or nums[start] != target:
            return [-1, -1]
            
        # 寻找结束位置
        end = find_first_greater(nums, target) - 1
        
        return [start, end]

```

---

#### `4. 总结与回顾`

- **核心是单调性**：二分查找能用的前提是数组（或数据范围）具有单调性，这样才能应用“染色法”。
    
- **蓝红染色法**：这是一个强大的思维模型，帮你把问题转化为寻找“边界”。
    
- **确定边界条件**：想清楚你要找的是“第一个 >= target”还是“最后一个 <= target”等，这决定了你的 `if` 判断条件和 `L`, `R` 的移动策略。
    
- **闭区间模板 (`L<=R`)**：对初学者最友好，通过改变 `if` 里的判断和后续的指针移动，可以解决几乎所有二分查找问题。
    

希望这份笔记能帮你建立起对二分查找清晰而深刻的理解！记住，多在 LeetCode 上找相关题目练习，才能真正将模板内化于心。祝你刷题愉快！




# 学习资料
- [灵茶山艾府](https://www.bilibili.com/video/BV1AP41137w7/?vd_source=54291517f0e970812239345528e873cf)
