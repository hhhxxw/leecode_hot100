# 思路
初始化棋盘，默认都是'.', 就开始遍历每一个位置，考虑这个位置是否可以放
```java
class Solution {

    List<List<String>> res = new ArrayList<>();

    List<String> list = new ArrayList<>();

    public List<List<String>> solveNQueens(int n) {

        // 初始化棋盘

        char[][] gird = new char[n][n];

        for(int i = 0; i < n; i ++){

            for(int j = 0; j < n; j ++){

                char[i][j] = '.';

            }

        }

        // 放棋子

        backtrack(gird);

        for(int i = 0; i < n; i ++){

            StringBuilder str = new StringBuilder();

            for(int j = 0; j < n; j ++){

                str.append(gird[i][j]);

            }

            res.add(str.toString());

        }

        return res;

    }

    public void backtrack(char[][] gird){

        if(gird[i][j] == '.' && isValid(i, j)){

            gird[i][j] = 'Q';

        }

    }

    // 判断当前位置是否可以放

}
```
# 提示词
使用知识点思路，反推题目如何解决

# 笔记
这比之前的“组合”和“分割”问题稍微复杂，因为它引入了二维棋盘和更多维度的约束。

这恰好是检验我们从文档中学到的“回溯心法”的最佳试金石。我们将严格按照“**答案的视角**”和“**回溯三问**”来庖丁解牛。

---

# 🚀 算法通法实践：精讲 LeetCode 51. N皇后

> [!NOTE] 题目要求
> 
> 在一个 N x N 的棋盘上，放置 N 个皇后，要求任何两个皇后都不能互相攻击。
> 
> 攻击规则：两个皇后不能在同一行、同一列或同一条斜线上。
> 
> 目标：找出所有不同的解决方案。

---

## 1. 套用“回溯三问”，构建解题框架

N皇后问题，本质上也是一个“构建答案”的过程，所以我们采用“**答案的视角**”来思考。

一个非常自然的思路是：**一行只放一个皇后**。我们从第0行开始，决定这一行的皇后应该放在哪一列；然后去第1行，再决定它的皇后应该放在哪一列……直到第N-1行。

好了，我们的递归函数轮廓就出来了：`dfs(row)`，它的意思是“**在第 `row` 行，我们应该把皇后放在哪一列？**”

现在，我们来回答“**回溯三问**”：

> [!TIP] 回溯三问 for N皇后
> 
> 1. 当前操作 (Current Operation)：
>     
>     在当前的 row 行，我有哪些选择？
>     
>     我的选择是从第0列到第 N-1 列，遍历每一列，尝试在 (row, col) 这个位置放置一个皇后。
>     
> 2. 子问题 (Subproblem)：
>     
>     当我决定在 (row, col) 位置放下一个皇后之后，剩下的问题是什么？
>     
>     剩下的问题就是：“如何在 row+1 到 N-1 这些行里，也同样合法地放置剩下的皇后？”
>     
> 3. 下一个子问题 (Next Subproblem)：
>     
>     我应该如何调用递归函数来解决这个子问题？
>     
>     很简单，我们只需要去解决下一行的问题，所以递归调用就是 dfs(row + 1)。
>     

通过这三问，我们的回溯主框架就搭建起来了，它会是一个 `for` 循环（遍历列）内嵌一个递归调用。

---

## 2. 核心难点：如何判断攻击 (剪枝)

在“当前操作”中，我们不能在任意一列都放皇后，必须判断 `(row, col)` 这个位置是否会被之前已经放置的皇后攻击到。这就是回溯中的“**剪枝**”，即提前排除掉无效的选择。

我们需要一个 `isValid(row, col)` 函数来检查。根据规则，我们需要检查三条线：

1. **正上方**：当前列 `col` 是否已经有皇后了？
    
2. **左上方斜线**：`y = -x + b`，即 `x+y` 的值是固定的。
    
3. **右上方斜线**：`y = x + b`，即 `y-x` 的值是固定的。
    

每次都循环检查这些位置效率太低。我们可以“用空间换时间”，用几个数组来 O(1) 地判断：

- `boolean[] colsUsed`: 一个大小为N的数组，`colsUsed[j] = true` 表示第 `j` 列已经被占用。
    
- `boolean[] diag1Used`: 记录左上到右下方向的斜线。这条线上所有格子的 `row - col` 的值是相等的。但 `row-col` 可能是负数，所以我们给它一个偏移量 `n-1`，用 `diag1Used[row - col + n - 1]` 来记录。
    
- `boolean[] diag2Used`: 记录右上到左下方向的斜线。这条线上所有格子的 `row + col` 的值是相等的，我们用 `diag2Used[row + col]` 来记录。
    

---

## 3. Java 代码实现与注释

Java

```java
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

class Solution {
    // 最终结果列表
    List<List<String>> result = new ArrayList<>();
    // 用于O(1)判断列是否被占用
    boolean[] colsUsed;
    // 用于O(1)判断左上->右下对角线是否被占用 (row - col)
    boolean[] diag1Used;
    // 用于O(1)判断右上->左下对角线是否被占用 (row + col)
    boolean[] diag2Used;
    // 棋盘大小
    int n;
    // 临时存储当前棋盘的布局
    char[][] board;

    public List<List<String>> solveNQueens(int n) {
        // --- 初始化 ---
        this.n = n;
        this.colsUsed = new boolean[n];
        // 对角线数量是 2n-1
        this.diag1Used = new boolean[2 * n - 1];
        this.diag2Used = new boolean[2 * n - 1];
        this.board = new char[n][n];
        // 初始化棋盘，所有位置都为空 '.'
        for (char[] row : board) {
            Arrays.fill(row, '.');
        }

        // 从第 0 行开始回溯
        backtrack(0);
        return result;
    }

    /**
     * 回溯函数
     * @param row 当前正在决策的行
     */
    private void backtrack(int row) {
        // --- 递归终止条件 ---
        // 如果成功处理完所有行（从0到n-1），说明找到了一个完整的解
        if (row == n) {
            // 将当前的棋盘布局转换为 List<String> 格式，并加入结果集
            result.add(convertBoardToList());
            return;
        }

        // --- 遍历当前行的所有列，为当前行的皇后寻找位置 ---
        for (int col = 0; col < n; col++) {
            // --- 剪枝判断：检查 (row, col) 位置是否合法 ---
            int d1Index = row - col + n - 1;
            int d2Index = row + col;
            if (colsUsed[col] || diag1Used[d1Index] || diag2Used[d2Index]) {
                // 如果该位置的列或对角线已被占用，则跳过
                continue;
            }

            // --- 1. 做选择 (Choose) ---
            board[row][col] = 'Q';
            colsUsed[col] = true;
            diag1Used[d1Index] = true;
            diag2Used[d2Index] = true;

            // --- 2. 探索 (Explore) ---
            // 进入下一行进行决策
            backtrack(row + 1);

            // --- 3. 撤销选择 (Un-choose / Backtrack) ---
            // 无论下一行的决策成功与否，都要恢复现场，
            // 以便 for 循环能正确地尝试当前行的下一个位置
            board[row][col] = '.';
            colsUsed[col] = false;
            diag1Used[d1Index] = false;
            diag2Used[d2Index] = false;
        }
    }

    /**
     * 将 char[][] 棋盘转换为 List<String> 的辅助函数
     */
    private List<String> convertBoardToList() {
        List<String> list = new ArrayList<>();
        for (char[] row : board) {
            list.add(new String(row));
        }
        return list;
    }
}
```

---

## 4. 复杂度分析

- **时间复杂度：O(N!)**
    
    - 这是一个粗略的上界。递归树的第 `k` 层最多有 `N-k` 个节点，总的节点数大致是 N! 级别的。虽然有剪枝，但搜索空间仍然是巨大的。
        
- **空间复杂度：O(N)**
    
    - 递归调用栈的深度最多为 N。
        
    - 我们使用的 `colsUsed`, `diag1Used`, `diag2Used` 等辅助数组的空间都是 O(N) 级别的。
        
    - `board` 棋盘本身占用了 O(N²) 空间，如果计入，则空间复杂度是 O(N²)。在算法分析中，通常更关注与递归深度相关的 O(N) 部分。
        

---

## 5. 触类旁通：回溯思想的“全家桶”

N皇后是解决**排列**和**棋盘**类回溯问题的绝佳模板。掌握它之后，你可以挑战：

- [[52. N皇后 II]]: 几乎一样，只是不需要返回棋盘，而是返回解的总数。
    
- [[37. 解数独]]: 另一个经典的棋盘回溯问题，约束条件更复杂。
    
- [[46. 全排列]]: 经典的回溯问题，可以对比一下和N皇后在“剪枝”逻辑上的不同。
    

通过N皇后问题，你可以深刻体会到，回溯算法的威力在于它能通过“递归”暴力探索所有可能性，又通过“剪枝”聪明地避开大量无效的搜索，从而在巨大的状态空间中找到所有解。