# 思路
从网格中找到第一个字符，然后从这个字符开始进行深度优先搜索,这个代码只能通过：35 / 88案例
```java
class Solution {

    int[][] direct = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};

    public boolean exist(char[][] board, String word) {

        // 取出第一个字符

        char start = word.charAt(0);

        int m = board.length;

        int n = board[0].length;

        for(int i = 0; i < m; i ++){

            for(int j = 0; j < n; j ++){

                if(board[i][j] == start){

                    // 找到第一个字符，开始进行dfs

                    return dfs(board, i, j, word,1);

                }

            }

        }

        // 如果没有找到，就返回false

        return false;

    }

    public boolean dfs(char[][] board, int i, int j, String word, int index){

        if(index == word.length()){

            return true;

        }

        for(int k = 0; k < 4; k ++){

            int nextX = i + direct[k][0];

            int nextY = j + direct[k][1];

  

            if(nextX >= 0 && nextX < board.length && nextY >= 0 && nextY < board[0].length){

                 if(board[nextX][nextY] == word.charAt(index)){

                    dfs(board, nextX, nextY,word,index + 1);  

                 }

            }

        }

        return false;

    }

}
```

# 提示词
```txt
# 角色和目标

你好，请你扮演一位资深的Java开发工程师，同时也是一位擅长讲解算法的导师。

我的目标是彻底理解力扣79. 单词搜索，并学习解决这类问题的通用思路。请你以一个初级Java程序员能完全听懂的方式，为我提供详细的指导。

# 题目

79. 单词搜索， 理解题目含义，样例输入输出

# 我的思路

从网格中找到第一个字符，然后从这个字符开始进行深度优先搜索,这个代码只能通过：35 / 88案例
```java
class Solution {

    int[][] direct = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};

    public boolean exist(char[][] board, String word) {

        // 取出第一个字符

        char start = word.charAt(0);

        int m = board.length;

        int n = board[0].length;

        for(int i = 0; i < m; i ++){

            for(int j = 0; j < n; j ++){

                if(board[i][j] == start){

                    // 找到第一个字符，开始进行dfs

                    return dfs(board, i, j, word,1);

                }

            }

        }

        // 如果没有找到，就返回false

        return false;

    }

    public boolean dfs(char[][] board, int i, int j, String word, int index){

        if(index == word.length()){

            return true;

        }

        for(int k = 0; k < 4; k ++){

            int nextX = i + direct[k][0];

            int nextY = j + direct[k][1];

  

            if(nextX >= 0 && nextX < board.length && nextY >= 0 && nextY < board[0].length){

                 if(board[nextX][nextY] == word.charAt(index)){

                    dfs(board, nextX, nextY,word,index + 1);  

                 }

            }

        }

        return false;

    }

}

# 我的困惑

为什么按照我的思路，不能完全通过这道题目，当我面试做算法题目遇到这种情况，我该如何处理

# 我希望的输出

请你根据以上信息，为我提供一份详细的题解，并满足以下要求：

1. 思路讲解：首先，请确认我的思路是否正确。然后，用通俗易懂的语言，分步骤详细讲解正确的解题思路，特别是针对我的困惑点进行解答。

2. 数据结构选择：选择合适的数据结构，并讲解为什么使用该数据结构

3. Java代码实现：提供一份完整、可运行的Java代码。 

4. 代码注释： 请在代码的关键部分加上详细的注释，解释这行代码（或代码块）的作用，让我能逐行理解。 

5. 复杂度分析： 在代码之后，请分析该算法的时间复杂度和空间复杂度。

6. 给出leecode相同思路的题目

7. 给出的笔记符合obsidian格式
```

优化之后的AC代码

```java
class Solution {

    int[][] direct = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};

    public boolean exist(char[][] board, String word) {

        // 取出第一个字符

        char start = word.charAt(0);

        int m = board.length;

        int n = board[0].length;

        boolean [][] flag = new boolean[m][n];

        for(int i = 0; i < m; i ++){

            for(int j = 0; j < n; j ++){

                if(board[i][j] == start){

                    // 找到第一个字符，开始进行dfs

                    flag[i][j] = true;

                    if(dfs(board, i, j, word,1, flag)){

                        return true;

                    }

                    flag[i][j] = false;;

                }

            }

        }

        // 如果没有找到，就返回false

        return false;

    }

    public boolean dfs(char[][] board, int i, int j, String word, int index, boolean[][] flag){

        if(index == word.length()){

            return true;

        }

        for(int k = 0; k < 4; k ++){

            int nextX = i + direct[k][0];

            int nextY = j + direct[k][1];

  

            if(nextX >= 0 && nextX < board.length && nextY >= 0 && nextY < board[0].length){

                 if(board[nextX][nextY] == word.charAt(index) && flag[nextX][nextY] == false){

                    flag[nextX][nextY] = true;

                    if(dfs(board, nextX, nextY,word,index + 1, flag)){

                        return true;

                    }  

                    flag[nextX][nextY] = false;

                 }

            }

        }

        return false;

    }

}
```
# 题解

你好！很高兴能再次担任你的Java导师。你这次遇到的问题非常典型，是面试中考察回溯算法和深度优先搜索（DFS）的明星题目。

首先，我要告诉你，你的思路大方向是完全正确的——**“从网格中找到第一个字符，然后从这个字符开始进行深度优先搜索”**，这正是解决这类网格问题的核心！你的代码没能完全通过，是因为在实现这个思路时，遗漏了几个非常关键的细节。这在学习过程中非常正常，我们今天的目标就是把这些细节彻底搞清楚。

---

## 1. 思路讲解

### a. 你的思路为什么不完全正确？

我们来分析一下你的代码，看看问题出在哪里。这就像在工作中做Code Review，找出潜在的bug。

你的代码有三个主要的逻辑缺陷：

1. **“一票否决”的错误**：在你的主函数 `exist` 中，你找到了第一个匹配的起始字符后，就立刻调用 `return dfs(...)`。这意味着，如果从**第一个**找到的 `'A'` 开始的搜索路径失败了，你的整个函数就直接返回 `false` 了，根本不会去尝试从网格中**其他**的 `'A'` 开始的新路径。正确的做法应该是，只有当一条路径搜索成功时才立刻返回 `true`，如果失败了，则需要继续循环，尝试下一个可能的起点。
    
2. **“不关心结果”的递归**：在你的 `dfs` 函数中，你调用了 `dfs(board, nextX, nextY,word,index + 1);`，但你没有对它的返回值做任何处理。递归函数返回的 `boolean` 值（`true` 或 `false`）是告诉你“从这条路走下去，能找到答案吗？”的信息。你必须接收这个信息，如果它返回 `true`，说明找到了一条完整路径，你也应该立刻向上层返回 `true`。
    
3. **“走回头路”的问题（最关键的缺陷）**：题目要求“同一个单元格内的字母不允许被重复使用”。你的代码没有机制来阻止这一点。想象一下路径 `A -> B`，你的DFS可以从B再走回到A，这样就无限循环了，或者错误地使用了同一个字符两次。
    

### b. 如何在面试中处理这种情况？

当你在面试中发现代码无法通过所有用例时，这是一个展示你调试和逻辑思维能力的好机会。你可以这样做：

1. **复述题目关键约束**：“我再确认一下题目的要求，‘同一个单元格内的字母不允许被重复使用’，这非常关键。”
    
2. **审视自己的代码**：“我的当前代码在递归时，没有记录哪些单元格已经被用过，所以它可能会走回头路，违反了这个约束。这是我需要修复的核心问题。”
    
3. **提出解决方案**：“为了解决这个问题，我需要在每次DFS搜索时，记录下当前路径已经访问过的节点。一个方法是使用一个`boolean[][] visited`的辅助矩阵。一个更节省空间的技巧是，在进入一个单元格时，先将它临时修改成一个特殊字符（比如'#'），防止它被再次访问。当从这个单元格回溯时，再把它改回原来的字符，这样它就不会影响到其他的搜索路径了。”
    

这个思考过程能清晰地向面试官展示你的逻辑能力和问题解决能力。

### c. 正确的解题思路：深度优先搜索 + 回溯

这道题是典型的**回溯算法**在矩阵中的应用。我们可以把它想象成一个“探路”的过程。

**核心思想：选择、探索、撤销**

1. **遍历起点**：从网格的每一个单元格 `(i, j)` 出发，尝试把它作为单词的起始点。
    
2. **深度优先搜索 (DFS)**：从这个起点开始，进行递归搜索。
    
    - **递归函数的定义**：`dfs(board, word, i, j, k)` 表示我们当前在网格的 `(i, j)` 位置，正在尝试匹配 `word` 的第 `k` 个字符。
        
    - **递归的终止条件**：
        
        - **失败**：当前位置越界了，或者当前单元格的字符与我们要匹配的 `word.charAt(k)` 不符。
            
        - **成功**：`k` 已经等于 `word.length() - 1`，说明单词的所有字符都已成功匹配。
            
    - **“做选择”（标记路径）**：为了防止走回头路，我们将当前单元格 `board[i][j]` 标记为“已访问”。一个巧妙的方法是将其临时修改为一个不存在于字母表中的特殊字符，如 `#`。
        
    - **“探索”（向四周递归）**：向当前单元格的上、下、左、右四个方向进行递归探索，尝试匹配 `word` 的下一个字符 `k+1`。只要**任意一个方向**的探索最终成功了，就说明找到了一条路径。
        
    - **“撤销选择”（回溯）**：**这是回溯的精髓！** 在对当前单元格 `(i, j)` 的所有方向都探索完毕后（无论成功还是失败），我们必须将它**恢复成原来的字符**。为什么要这样做？因为这条搜索路径结束了，但这个单元格可能在**另一条完全不同的搜索路径**中被需要。
        

---

## 2. 数据结构选择

- `char[][] board`: 题目给定的二维数组，作为我们的“地图”。
    
- `String word`: 目标单词。
    
- **递归调用栈 (Call Stack)**: DFS算法天然地使用调用栈来存储当前的搜索路径和状态。
    
- **原地修改/标记数组**: 我们选择直接在 `board` 上进行修改来标记已访问的节点，而不是创建一个新的 `boolean[][] visited` 数组。这样做的好处是**空间复杂度更低**，是面试中更优的解法。
    

---

## 3. Java 代码实现与注释

这是结合了上述回溯思想的完整、正确的Java代码。

Java

```
class Solution {

    /**
     * 主函数，用于启动单词搜索
     * @param board 字符网格
     * @param word  要搜索的单词
     * @return 如果能在网格中找到该单词，返回true，否则返回false
     */
    public boolean exist(char[][] board, String word) {
        int m = board.length;
        int n = board[0].length;

        // 遍历网格中的每一个单元格，尝试将其作为起点
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                // 如果从(i, j)出发的深度优先搜索能够找到单词，则直接返回true
                if (dfs(board, word, i, j, 0)) {
                    return true;
                }
            }
        }
        // 如果遍历完所有单元格都找不到，则返回false
        return false;
    }

    /**
     * 深度优先搜索（回溯）辅助函数
     * @param board 网格
     * @param word  目标单词
     * @param i     当前单元格的行索引
     * @param j     当前单元格的列索引
     * @param k     当前正在匹配单词的第k个字符
     * @return 是否能从(i,j)开始找到单词的剩余部分
     */
    private boolean dfs(char[][] board, String word, int i, int j, int k) {
        // --- 递归的终止条件（剪枝）---
        // 1. 越界检查：当前坐标超出了网格范围
        // 2. 字符不匹配：当前单元格的字符与目标字符不符
        if (i < 0 || i >= board.length || j < 0 || j >= board[0].length || board[i][j] != word.charAt(k)) {
            return false;
        }

        // --- 递归的成功终止条件 ---
        // 如果已经成功匹配到单词的最后一个字符
        if (k == word.length() - 1) {
            return true;
        }

        // --- 做选择：标记当前单元格为已访问 ---
        // 将当前单元格的字符保存起来，用于后续的回溯恢复
        char temp = board[i][j];
        // 修改为特殊字符'#'，表示此路已走，防止重复访问
        board[i][j] = '#';

        // --- 探索：向四个方向进行递归 ---
        // 只要有一个方向能走通，就说明找到了路径
        boolean found = dfs(board, word, i + 1, j, k + 1)  // 向下
                     || dfs(board, word, i - 1, j, k + 1)  // 向上
                     || dfs(board, word, i, j + 1, k + 1)  // 向右
                     || dfs(board, word, i, j - 1, k + 1); // 向左

        // --- 撤销选择（回溯） ---
        // 无论是否找到路径，都需要将当前单元格恢复为原始字符，
        // 以确保不影响从其他起点开始的搜索路径。
        board[i][j] = temp;

        return found;
    }
}
```

---

## 4. 复杂度分析

- **时间复杂度：O(M * N * 3^L)**
    
    - `M` 和 `N` 分别是网格的行数和列数。
        
    - `L` 是要搜索的单词的长度。
        
    - 我们最多会从 `M * N` 个单元格开始搜索。
        
    - 对于每次DFS，在除第一个字符外的每一步，我们最多有3个方向可以探索（因为不能走回头路）。所以最坏情况下的搜索路径数量级是 `3^L`。
        
    - 因此，总的时间复杂度是 `O(M * N * 3^L)`。
        
- **空间复杂度：O(L)**
    
    - 空间复杂度主要取决于递归调用的深度。在最坏的情况下，递归深度等于单词的长度 `L`。
        
    - 因为我们采用了原地修改的方式来标记已访问节点，所以没有使用额外的 `visited` 矩阵，节省了 `O(M * N)` 的空间。
        

---

## 5. 触类旁通：回溯思想的“全家桶”

掌握了这种在网格中进行“DFS + 回溯”的模板，你就可以解决一大批类似的问题：

- **[[200. 岛屿数量]]**: 经典的网格DFS应用，用于计算连通分量的数量。
    
- **[[46. 全排列]]**: 经典的回溯算法，虽然不是网格，但“选择、探索、撤销”的思想是完全一致的。
    
- **[[78. 子集]]**: 另一个经典的回溯问题。
    
- **[[130. 被围绕的区域]]**: 从边界出发的网格DFS，思路巧妙。
    
- **[[212. 单词搜索 II]]**: 本题的进阶版，需要结合**前缀树（Trie）**进行优化，是面试中的高频难题。
    

希望这份详细的讲解能帮你彻底攻克这道题，并对回溯算法有一个更深的理解！如果还有任何疑问，随时都可以再提出来。