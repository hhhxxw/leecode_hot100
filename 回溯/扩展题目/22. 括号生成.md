# 我的思路
```java
class Solution {

    // 用于存储结果

    List<String> res = new ArrayList<>();

    public List<String> generateParenthesis(int n) {

        if(n == 0){

            return res;

        }

        backtrack(n, 0,n, n, new StringBuilder());

        return res;

    }

    public void backtrack(int n, int index,int leftNum, int rightNum,  StringBuilder path){

        if(index == 2 * n){

            res.add(path.toString());

        }

        path.append('(');

        leftNum --;

        backtrack(n, index + 1,leftNum, rightNum, path);

        if(n - rightNum < n - leftNum){

            path.append(')');

            rightNum --;
        }
    }
}
```

# 提示词
```txt
# 角色和目标

你好，请你扮演一位资深的Java开发工程师，同时也是一位擅长讲解算法的导师。

我的目标是彻底理解力扣22. 括号生成的这道题目，并学习解决这类问题的通用思路。请你以一个初级Java程序员能完全听懂的方式，为我提供详细的指导。

# 题目

22. 括号生成， 理解题目含义，样例输入输出

# 我的思路
回溯算法，理解我的代码，分析总结思路

class Solution {

    // 用于存储结果

    List<String> res = new ArrayList<>();

    public List<String> generateParenthesis(int n) {

        if(n == 0){

            return res;

        }

        backtrack(n, 0,n, n, new StringBuilder());

        return res;

    }

    public void backtrack(int n, int index,int leftNum, int rightNum,  StringBuilder path){

        if(index == 2 * n){

            res.add(path.toString());

        }

        path.append('(');

        leftNum --;

        backtrack(n, index + 1,leftNum, rightNum, path);

        if(n - rightNum < n - leftNum){

            path.append(')');

            rightNum --;
        }
    }
}

# 我的困惑

运行报错
java.lang.StackOverflowError at line 806, java.base/java.lang.AbstractStringBuilder.append at line 246, java.base/java.lang.StringBuilder.append at line 15, Solution.backtrack at line 17, Solution.backtrack at line 17, Solution.backtrack at line 17, Solution.backtrack at line 17, Solution.backtrack at line 17, Solution.backtrack at line 17, Solution.backtrack at line 17, Solution.backtrack

# 我希望的输出

请你根据以上信息，为我提供一份详细的题解，并满足以下要求：

1. 思路讲解：首先，请确认我的思路是否正确。然后，用通俗易懂的语言，分步骤详细讲解正确的解题思路，特别是针对我的困惑点进行解答。

2. 数据结构选择：选择合适的数据结构，并讲解为什么使用该数据结构

3. Java代码实现：提供一份完整、可运行的Java代码。 

4. 代码注释： 请在代码的关键部分加上详细的注释，解释这行代码（或代码块）的作用，让我能逐行理解。 

5. 复杂度分析： 在代码之后，请分析该算法的时间复杂度和空间复杂度。
 
6. 给出leecode相同思路的题目

7.笔记格式符合obsidian格式 
```

# 题解

----
# LeetCode 22. 括号生成 - 深度解析与回溯算法模板

`#algorithm` `#java` `#leetcode` `#backtracking` `#recursion`

> [!INFO] 写在前面
> 
> 你好！首先，我要为你点个赞！你已经找到了解决这个问题的正确方向——回溯算法，并且你尝试编写了代码，这是成为优秀工程师的必经之路。遇到 StackOverflowError 是学习递归和回溯时非常经典的经历，这恰恰说明我们即将突破一个重要的知识点。

## 1. 题目解析

- **目标**：输入一个正整数 `n`，代表括号的对数。我们需要生成所有可能的、并且**有效**的括号组合。
    
- **样例**：
    
    - 输入: `n = 3`
        
    - 输出: `["((()))","(()())","(())()","()(())","()()()"]`
        
    - 输入: `n = 1`
        
    - 输出: `["()"]`
        
- **核心要点**：“有效”是关键。`)(` 是无效的，`())` 也是无效的。一个有效的括号组合，在从左到右的任何位置，右括号 `)` 的数量都不能超过左括号 `(` 的数量。
    

## 2. 思路讲解：回溯法的“选择”与“撤销”

你的核心思路是正确的，这个问题是回溯算法的典型应用场景。

> [!BUG] 你的困惑点：为什么会 StackOverflowError？
> 
> 让我们来分析你的代码。在 backtrack 方法中，你无条件地 path.append('(')，然后立即进行递归。
> 
> Java
> 
> ```
> path.append('(');
> leftNum --;
> backtrack(n, index + 1,leftNum, rightNum, path); // 递归下去
> ```
> 
> 问题在于，你的递归调用链是单向的，就像一条路走到黑。`backtrack` 调用 `backtrack`，后者又调用 `backtrack`... 在这个过程中，你**没有“撤销”你的选择**。`path` 这个 `StringBuilder` 被不断地添加 `(`，它的状态没有在探索完一个分支后恢复原状。
> 
> 递归如果没有正确的终止或回退机制，就会无限进行下去，直到调用栈（Call Stack）被耗尽，最终抛出 `StackOverflowError`。

> [!TIP] 正确的回溯思路：走不通就退回来
> 
> 想象一下你在走一个迷宫，回溯算法就像探索这个迷宫的过程：
> 
> - **选择 (Choose)**: 在一个岔路口，你选择一条路走下去。
>     
> - **探索 (Explore)**: 沿着这条路继续前进，如果又遇到岔路口，就再做一次选择。
>     
> - **撤销 (Unchoose/Backtrack)**: 如果你发现这条路是死胡同（不满足题目条件），或者你已经走到底（找到一个解），你就必须**退回到上一个走过的岔路口**，然后尝试另一条没走过的路。
>     
> 
> 对应到我们这道题：
> 
> - **迷宫的路径**: 就是我们正在构建的括号字符串（`path`）。
>     
> - **岔路口**: 在构建字符串的每一步，我们都有两种选择：添加 `(` 或添加 `)`。
>     
> - **死胡同 (剪枝)**: 我们不能随意添加括号。规则是：
>     
>     1. 左括号 `(` 只要还有剩余（使用数量 < n），就可以添加。
>         
>     2. 右括号 `)` 的数量必须始终小于左括号的数量，才能添加。这是保证有效性的关键。
>         
> - **走到底 (找到解)**: 当字符串的长度达到 `2 * n` 时，我们就找到了一个完整的、有效的括号组合。
>     
> - **退回到上一个路口 (关键步骤！)**: 当你基于某个选择（比如在 `("` 后添加了 `("` 变成了 `"(("`）的所有可能性都探索完毕后，你需要把这个选择撤销掉（把 `"(("` 变回 `("`），这样才能去尝试其他的选择（比如在 `("` 后添加 `")"` 变成 `()`)。这就是你的代码中缺失的核心部分。
>     

## 3. 数据结构选择

1. `List<String> result` (使用 `ArrayList`)
    
    - **作用**：存储最终结果集，用于保存所有找到的有效括号组合。
        
    - **原因**：`ArrayList` 是动态数组，非常适合用于存储数量不定的结果。
        
2. `StringBuilder path`
    
    - **作用**：保存我们在递归探索中“当前走过的路径”。
        
    - **原因**：
        
        - **效率**: `String` 对象是不可变的 (immutable)。每次对 `String` 进行拼接（如 `str = str + "("`）都会创建一个新的 `String` 对象，这在递归中会产生大量的内存开销，非常低效。
            
        - **回溯的需要**: `StringBuilder` 是可变的 (mutable)，它提供了 `append()` 和 `deleteCharAt()` 这样的方法，可以让我们在同一个对象上进行修改。这完美契合了回溯算法中“选择” (`append`) 和“撤销” (`deleteCharAt`) 的操作，效率极高。
            

## 4. Java 代码实现

> [!SUCCESS] 完整可运行的 Java 代码

```java
import java.util.ArrayList;
import java.util.List;

class Solution {

    // 用于存储最终结果的列表
    List<String> result = new ArrayList<>();

    /**
     * 主函数，启动回溯过程
     * @param n 括号的对数
     * @return 所有有效的括号组合
     */
    public List<String> generateParenthesis(int n) {
        // 如果 n 为 0 或负数，直接返回空列表
        if (n <= 0) {
            return result;
        }
        // 调用回溯方法，初始状态：路径为空，左右括号都还没用
        backtrack(new StringBuilder(), 0, 0, n);
        return result;
    }

    /**
     * 回溯核心方法（深度优先搜索 DFS）
     * @param currentPath 当前正在构建的字符串路径
     * @param openUsed    已经使用的左括号数量
     * @param closeUsed   已经使用的右括号数量
     * @param maxPairs    括号的总对数 n
     */
    private void backtrack(StringBuilder currentPath, int openUsed, int closeUsed, int maxPairs) {
        // --- 终止条件 ---
        // 当构建的字符串长度等于 2 * n 时，说明找到了一个完整的组合
        if (currentPath.length() == maxPairs * 2) {
            // 将当前路径的字符串形式添加到结果集中
            result.add(currentPath.toString());
            // 结束当前递归分支
            return;
        }

        // --- 做出选择 & 探索 ---

        // 选择1：尝试添加左括号 '('
        // 剪枝条件：只要已使用的左括号数量小于总对数 n，就可以添加
        if (openUsed < maxPairs) {
            // 1. 做出选择
            currentPath.append('(');
            // 2. 进入下一层决策树（递归），并更新状态
            backtrack(currentPath, openUsed + 1, closeUsed, maxPairs);
            // 3. 撤销选择：这是回溯的精髓！
            //    将路径恢复到上一状态，以便探索其他可能性（比如在这个位置添加右括号）
            currentPath.deleteCharAt(currentPath.length() - 1);
        }

        // 选择2：尝试添加右括号 ')'
        // 剪枝条件：只有当已使用的右括号数量严格小于已使用的左括号数量时，才能添加
        // 这是为了保证括号的合法性，如 "())" 是不合法的
        if (closeUsed < openUsed) {
            // 1. 做出选择
            currentPath.append(')');
            // 2. 进入下一层决策树（递归），并更新状态
            backtrack(currentPath, openUsed, closeUsed + 1, maxPairs);
            // 3. 撤销选择：同上，恢复现场
            currentPath.deleteCharAt(currentPath.length() - 1);
        }
    }
}
```

## 5. 复杂度分析

- **时间复杂度**: O(frac4nsqrtn)
    
    - 这个问题的解的数量符合数学上的**卡特兰数 (Catalan number)**，第 `n` 个卡特兰数记作 C_n。
        
    - C_n=frac1n+1binom2nn，其数量级大致是 frac4nnsqrtpin。
        
    - 回溯算法会访问到所有有效的解，并为每个解构建一个长度为 `2n` 的字符串。因此，时间复杂度与解的数量和解的长度成正比。对于面试来说，能够解释清楚这是一个指数级的复杂度，并且与卡特兰数相关，就已经非常出色了。
        
- **空间复杂度**: O(n)
    
    - 这个空间复杂度主要由递归调用栈的深度决定。
        
    - 递归树最深的情况就是像 `((...))` 这样，深度为 `2n`。所以调用栈和 `StringBuilder` 占用的空间都是 O(n)。
        
    - **注意**：此处的空间复杂度**不包括**存储最终结果的 `result` 列表。如果把输出结果也算进去，空间复杂度将是 O(ncdotC_n)=O(frac4nsqrtn)。
        

## 6. 触类旁通：相同思路的 LeetCode 题目

掌握了这种“选择-探索-撤销”的回溯模板后，你可以用它来解决一大批组合搜索类问题。这里有几个经典的例子，强烈建议你去练习（可以把这个列表做成你的练习 `Checklist`）：

- [x] [46. 全排列 (Permutations)](https://leetcode.cn/problems/permutations/)
    
- [x] [77. 组合 (Combinations)](https://leetcode.cn/problems/combinations/)
    
- [x] [78. 子集 (Subsets)](https://leetcode.cn/problems/subsets/)
    
- [ ] [39. 组合总和 (Combination Sum)](https://leetcode.cn/problems/combination-sum/)
    
- [x] [17. 电话号码的字母组合 (Letter Combinations of a Phone Number)](https://leetcode.cn/problems/letter-combinations-of-a-phone-number/)


---

希望这份笔记能帮助你彻底掌握这道题。如果在学习这些新题目时还有任何疑问，随时都可以再来找我！祝你刷题愉快，编程能力节节高升！