# 回溯的概念
回溯知识讲解的总览
![](img/Pasted%20image%2020250809100744.png)

通过一个案例，说明嵌套循环的局限性
![](img/Pasted%20image%2020250809100952.png)

联系递归，从原问题和子问题的角度考虑，原问题的解可以通过子问题的解来完成，那么就考虑使用递归算法
![](img/Pasted%20image%2020250809101443.png)

递归和回溯有什么关系？
![](img/Pasted%20image%2020250809101514.png)

递归的核心在于边界条件和非边界条件，如果这两个写对了，递归就是正确的，重点放在圈出来的部分
![](img/Pasted%20image%2020250809101931.png)

dfs(i)表示的是枚举大于等于i的部分，所以其子问题就是dfs(i + 1) ，所以是从dfs(i)递归到dfs(i + 1)
![](img/Pasted%20image%2020250809102107.png)

例题

```python
MAPPING = ["", "", "abc", "def", "ghi", "jkl", "mno", "pqrs", "tuv", "wxyz"]

class Solution(object):

    def letterCombinations(self, digits):

        n = len(digits)

        if n == 0:

            return []

        ans = []

        path = [''] * n

        # 进行递归

        def dfs(i):

            if i == n:

                ans.append(''.join(path))

                return

            for c in MAPPING[int(digits[i])]:

                path[i] = c

                dfs(i + 1)

  

        # 递归入口

        dfs(0)

        return ans
```

# 回溯套路
## 子集型回溯
### 模板一：输入的视角
> 每个元素都可以选或者不选

![](img/Pasted%20image%2020250812200321.png)

```python
def dfs(i):
	if i == n
		ans.append(path.copy())
		return

	// 不选
	def(i + 1)
	// 选
	path.append(nums[i])
	dfs(i + 1);
	// 恢复现场（递归之前）
	path.pop()
```

### 模板二：答案的视角
![](img/Pasted%20image%2020250812201123.png)
![](img/Pasted%20image%2020250812201158.png)
```python
def dfs(i):
	ans.append(path.copy())
	if i == n
		return
	for(j in range(i ,n))
		path.append(nums[i])
		dfs(i + 1);
		path.pop()
dfs(0)
```
### 例题-分割回文串
![](img/Pasted%20image%2020250812201810.png)

> 假设每两个字符之间都有一个逗号，对于每一个逗号，考虑选它还是不选它，这样就将问题转换为子集问题


![](img/Pasted%20image%2020250812201706.png)

> 从答案的视角分析

![](img/Pasted%20image%2020250812202020.png)

代码如下
```python
def dfs(i):
	if i == n
		ans.append(path.copy())
		return
	for(j in range(i ,n))
		t = s[i : j + 1];
			if t == t[::-1]:
				path.append(t);
				dfs(j + 1)
				path.pop()
dfs(0)
```


# AI总结
你好！很高兴能以你资深Java导师的身份，和你一同解析这份关于回溯算法的精彩文档。

你提供的这份文档质量非常高，它提炼了回溯算法的精髓，特别是“**回溯三问**”和两种不同的思考视角。这正是从“新手”到“高手”需要掌握的核心心法。

我的任务就是帮你把这些略显抽象的理论，转化为你能够轻松理解和上手的Java代码，并用它来攻克实际的LeetCode题目。

---

## 1. 提炼核心思想：回溯算法的“三问”法

文档的核心，是为你提供了一个思考回溯问题的通用“公式”——

**回溯三问** 1。无论问题怎么变，我们都可以用这三个问题来规范我们的思考过程：

> [!TIP] 回溯三问
> 
> 1.
> 
> 当前操作 (Current Operation)
> 
> ：在当前这一步，我有哪些选择可以做？
> 
> 2.
> 
> 子问题 (Subproblem)
> 
> ：当我做出一个选择后，剩下的问题是什么？这个子问题和原问题的结构是否一样？
> 
> 3.
> 
> 下一个子问题 (Next Subproblem) 
> 
> ：我应该如何设计递归函数的参数，来定义和解决这个规模更小的子问题？

只要你能清晰地回答这三个问题，任何回溯题目都能迎刃而解。

---

## 2. 剖析两种通用思路

文档中为你总结了解决“

**子集型回溯**” 5555 问题的两大派别，我们来逐一把它“翻译”成大白话和Java代码。

思路一：输入的视角 (The "Yes/No" Approach) 6666

这种思路非常纯粹，它模拟了我们面对一堆元素时最直接的思考过程。

- **核心比喻**：想象你站在一个自助餐台前，面前有一排菜（输入的数组）。对于每一道菜，你只有两种选择：**“取”** 还是 **“不取”**。当你把所有菜都考虑一遍后，你餐盘里的组合就是一种答案。
    
- **“回溯三问”应用**：
    
    - **当前操作**：对于当前元素 `nums[i]`，做“取”或“不取”的选择。 7
        
    - **子问题**：对 `nums` 从第 `i` 个元素开始的剩余部分，构造子集。 8
        
    - **下一个子问题**：无论取不取 `nums[i]`，下一步都要去处理第 `i+1` 个元素。所以递归调用总是 `dfs(i+1)`。 9
        

#### 实战演练：LeetCode 78. 子集

> **题目**：给你一个整数数组 `nums` ，数组中的元素 **互不相同** 。返回该数组所有可能的子集（幂集）。

**代码实现 (输入的视角):**

Java

```
import java.util.ArrayList;
import java.util.List;

class SolutionSubsets {

    List<List<Integer>> result = new ArrayList<>();
    List<Integer> path = new ArrayList<>(); // 存储当前路径（子集）

    public List<List<Integer>> subsets(int[] nums) {
        dfs(nums, 0);
        return result;
    }

    /**
     * @param nums  原始输入数组
     * @param i     当前决策点，决定是否要将 nums[i] 加入子集
     */
    private void dfs(int[] nums, int i) {
        // 递归终止条件：当 i 越过数组末尾，说明所有元素都已决策完毕
        if (i == nums.length) {
            // 将当前路径的“快照”加入结果集
            result.add(new ArrayList<>(path));
            return;
        }

        // --- 分支1：不选择 nums[i] ---
        // 直接跳到下一个元素去做决策
        dfs(nums, i + 1);

        // --- 分支2：选择 nums[i] ---
        // 1. 做选择
        path.add(nums[i]);
        // 2. 探索：进入下一层决策
        dfs(nums, i + 1);
        // 3. 撤销选择（回溯）：将 path 恢复到进入本分支前的状态，
        //    以便不影响其他分支的决策。
        path.remove(path.size() - 1);
    }
}
```

---

思路二：答案的视角 (The "Building Block" Approach) 10101010

这种思路更加直观，它模拟了我们“构建”答案的过程。

- **核心比喻**：想象你面前有一盒乐高积木（输入的数组），你要拼出一个作品（一个子集）。你每次都思考：“**我下一步应该从剩下的积木里，挑哪一块来拼呢？**”
    
- **“回溯三问”应用**：
    
    - **当前操作**：从 `i` 开始的剩余元素中，选择一个 `nums[j]` 加入到当前答案 `path` 中。 11
        
    - **子问题**：从 `i` 开始的剩余元素中，构造子集。 12
        
    - **下一个子问题**：为了避免重复（例如 `[1,2]` 和 `[2,1]`），我们规定，下一次只能从 `j+1` 开始的元素里挑选。 13
        
- **关键点**：这种思路下，递归树的**每个节点**本身都是一个合法的答案。 14
    

#### 实战演练：LeetCode 131. 分割回文串

> **题目**：给你一个字符串 `s`，请你将 `s` 分割成一些子串，使每个子串都是 **回文串** 。返回 `s` 的所有可能的分割方案。

这道题完美契合“答案的视角”。我们的“积木”就是各种可能的回文子串。

**代码实现 (答案的视角):**

Java

```
import java.util.ArrayList;
import java.util.List;

class SolutionPalindromePartition {

    List<List<String>> result = new ArrayList<>();
    List<String> path = new ArrayList<>(); // 存储当前路径（一种分割方案）

    public List<List<String>> partition(String s) {
        dfs(s, 0);
        return result;
    }

    /**
     * @param s          原始字符串
     * @param startIndex 当前切割的起始位置
     */
    private void dfs(String s, int startIndex) {
        // 递归终止条件：如果起始位置已经越过字符串末尾，
        // 说明找到了一组完整的分割方案。
        if (startIndex >= s.length()) {
            result.add(new ArrayList<>(path));
            return;
        }

        // for 循环用于枚举所有可能的“切割点”
        // i 是当前尝试切割的子串的结束位置
        for (int i = startIndex; i < s.length(); i++) {
            // 尝试切割出子串 s[startIndex...i]
            String sub = s.substring(startIndex, i + 1);

            // 检查这个“积木”是否合法（是否是回文）
            if (isPalindrome(sub)) {
                // 如果合法，就加入到当前方案中
                
                // 1. 做选择
                path.add(sub);
                // 2. 探索：从 i + 1 开始，继续对剩余部分进行切割
                dfs(s, i + 1);
                // 3. 撤销选择（回溯）
                path.remove(path.size() - 1);
            }
        }
    }

    // 判断字符串是否为回文的辅助函数
    private boolean isPalindrome(String s) {
        int left = 0, right = s.length() - 1;
        while (left < right) {
            if (s.charAt(left++) != s.charAt(right--)) {
                return false;
            }
        }
        return true;
    }
}
```

---

### 总结

|特性|思路一 (输入的视角)|思路二 (答案的视角)|
|---|---|---|
|**核心思想**|对每个元素做“选/不选”的二元决策|每次从剩余元素中“选一个”来构建答案|
|**递归结构**|通常是两次递归调用 `dfs(i+1)`|通常是一个 `for` 循环内嵌一次递归调用|
|**答案位置**|通常只在叶子节点产生答案|每个节点都可能是一个合法的答案|
|**适用场景**|子集问题|组合、分割、排列问题|

掌握了这份文档提炼出的这两种核心思路和“回溯三问”法，你就拥有了解决绝大多数回溯问题的“万能钥匙”。希望这份解析能让你茅塞顿开！
# 参考资料
- [回溯算法套路①子集型回溯【基础算法精讲 14】](https://www.bilibili.com/video/BV1mG4y1A7Gu/?vd_source=54291517f0e970812239345528e873cf)